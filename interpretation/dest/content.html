<h1 class="section-title"><a name="Basic Types" class="anchor" href="#Basic Types"><span class="header-link"></span></a>Basic Types</h1><div role="item"><p>程序要跑起来，离不开使用一些基本的数据类型，如：numbers, strings, structures, boolean等。在TypeScript中，所有你在JavaScript中用到的数据类型都会被支持，同时TypeScript还添加了便利的枚举类型（enumeration type）以供使用。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we support much the same types as you would expected in JavaScript, with a convenient enumeration type thrown in to help things along.
</p></div><h2 class="section-title"><a name="Boolean" class="anchor" href="#Boolean"><span class="header-link"></span></a>Boolean</h2><div role="item"><p>真/假值是最基本的数据类型，这种数据类型在JavaScript和TypeScript中（以及其他语言）称为布尔类型（boolean）。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The most basic datatype is the simple true/false value, which JavaScript and TypeScript (as well as other languages) call a &#39;boolean&#39; value.
</p></div><pre><code class="lang-js">var isDone: boolean = false;
</code></pre>
<h2 class="section-title"><a name="Number" class="anchor" href="#Number"><span class="header-link"></span></a>Number</h2><div role="item"><p>同JavaScript一样，TypeScript中数字数据都是浮点数。这些浮点数都被称作数字类型（number）。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">As in JavaScript, all numbers in TypeScript are floating point values. These floating point numbers get the type &#39;number&#39;.
</p></div><pre><code class="lang-js">var height: number = 6;
</code></pre>
<h2 class="section-title"><a name="String" class="anchor" href="#String"><span class="header-link"></span></a>String</h2><div role="item"><p>文本类型的数据是JavaScript编写网页和服务器等程序的基础之一。同其他语言一样，我们使用字符串（string）来指代这些文本类型的数据。在TypeScript中，你也可以像在JavaScript中那样，使用双引号（&quot;&quot;）或单引号（&#39;&#39;）来表示字符串。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Another fundamental part of creating programs in JavaScript for webpages and servers alike is working with textual data. As in other languages, we use the type &#39;string&#39; to refer to these textual datatypes. Just like JavaScript, TypeScript also uses the double quote (&quot;) or single quote (&#39;) to surround string data.
</p></div><pre><code class="lang-js">var name: string = &quot;bob&quot;;
name = &#39;smith&#39;;
</code></pre>
<h2 class="section-title"><a name="Array" class="anchor" href="#Array"><span class="header-link"></span></a>Array</h2><div role="item"><p>同JavaScript一样，TypeScript中我们也可以使用数组。我们可以使用两种不同的方式来书写数组。第一种是在元素类型后面附上中括号（[]），来表示该类型的数组：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">TypeScript, like JavaScript, allows you to work with arrays of values. Array types can be written in one of two ways. In the first, you use the type of the elements followed by &#39;[]&#39; to denote an array of that element type:
</p></div><pre><code class="lang-js">var list:number[] = [1, 2, 3];
</code></pre>
<div role="item"><p>第二种是使用泛型数组类型，形式如Array<elemType>：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The second way uses a generic array type, Array<elemType>:
</p></div><pre><code class="lang-js">var list:Array&lt;number&gt; = [1, 2, 3];
</code></pre>
<h2 class="section-title"><a name="枚举（Enum）" class="anchor" href="#枚举（Enum）"><span class="header-link"></span></a>枚举（Enum）</h2><div role="item"><p>TypeScript拓展了JavaScript原生的标准数据类型集，增加了枚举类型（enum）。枚举是一种很有用的数据类型，就像C#等语言中一样，它提供了一种给数字类型的值设置容易辨别的名字的方法。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">A helpful addition to the standard set of datatypes from JavaScript is the &#39;enum&#39;. Like languages like C#, an enum is a way of giving more friendly names to sets of numeric values.
</p></div><pre><code class="lang-js">enum Color {Red, Green, Blue};
var c: Color = Color.Green;
</code></pre>
<div role="item"><p>在默认情况下，枚举类型会从0开始标记它的元素。我们可以通过人为地设置元素的数值来改变默认值。例如，上面的例子我们可以设置从1开始计数：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">By default, enums begin numbering their members starting at 0. You can change this by manually setting the value of one its members. For example, we can start the previous example at 1 instead of 0:
</p></div><pre><code class="lang-js">enum Color {Red = 1, Green, Blue};
var c: Color = Color.Green;
</code></pre>
<div role="item"><p>我们甚至可以给所有的枚举元素设置数值：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Or, even manually set all the values in the enum:
</p></div><pre><code class="lang-js">enum Color {Red = 1, Green = 2, Blue = 4};
var c: Color = Color.Green;
</code></pre>
<div role="item"><p>枚举类型有一个便捷特性，我们也可以直接使用一个枚举元素的名对所对应的值。举例来说，如果我们有一个值为2,但我们不确定这个数值对应枚举类型中的哪个元素，那我们可以直接查找这个数值对应的名称：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">A handy feature of enums is that you can also go from a numeric value to the name of that value in the enum. For example, if we had the value 2 but weren&#39;t sure which that mapped to in the Color enum above, we could look up the corresponding name:
</p></div><pre><code class="lang-js">enum Color {Red = 1, Green, Blue};
var colorName: string = Color[2];

alert(colorName);
</code></pre>
<h2 class="section-title"><a name="Any" class="anchor" href="#Any"><span class="header-link"></span></a>Any</h2><div role="item"><p>当我们编写应用时，我们可能会需要描述一些类型不明确的变量。因为这些变量的值可能来源于一些动态的内容，比如用户或第三方提供的库。在这类情况下，我们可能想省却这些变量值的类型检查，就让它们直接通过编译时的检查。于是我们就可以把它们标识为&#39;any&#39;类型：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">We may need to describe the type of variables that we may not know when we are writing the application. These values may come from dynamic content, eg from the user or 3rd party library. In these cases, we want to opt-out of type-checking and let the values pass through compile-time checks. To do so, we label these with the &#39;any&#39; type:
</p></div><pre><code class="lang-js">var notSure: any = 4;
notSure = &quot;maybe a string instead&quot;;
notSure = false; // okay, definitely a boolean
</code></pre>
<div role="item"><p>&#39;any&#39;类型是我们处理已有的JavaScript代码的一种强大的方式。它允许我们在编译过程中，增加或绕过类型检查。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The &#39;any&#39; type is a powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out of type-checking during compilation.
</p></div><div role="item"><p>当我们知道一部分数据类型，却又不确定全部的数据类型时，使用&#39;any&#39;可以让我们方便不少。比如你有一个数组，但是这个数组中的元素属于不同的数据类型，那你可以这么做：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The &#39;any&#39; type is also handy if you know some part of the type, but perhaps not all of it. For example, you may have an array but the array has a mix of different types:
</p></div><pre><code class="lang-js">var list:any[] = [1, true, &quot;free&quot;];

list[1] = 100;
</code></pre>
<h2 class="section-title"><a name="Void" class="anchor" href="#Void"><span class="header-link"></span></a>Void</h2><div role="item"><p>与&#39;any&#39;对应的数据类型是&#39;void&#39;，它代表缺省类型。没有返回值的函数就可以认为是&#39;void&#39;类型：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Perhaps the opposite in some ways to &#39;any&#39; is &#39;void&#39;, the absence of having any type at all. You may commonly see this as the return type of functions that do not return a value:
</p></div><pre><code class="lang-js">function warnUser(): void {
    alert(&quot;This is my warning message&quot;);
}
</code></pre>
<h1 class="section-title"><a name="接口（Interfaces）" class="anchor" href="#接口（Interfaces）"><span class="header-link"></span></a>接口（Interfaces）</h1><div role="item"><p>类型检查将集中关注于数据的“形状”是TypeScript的核心原则之一。这有时又被称作“duck typing”或“structural subtyping”。在TypeScript中，接口起到了罗列这些数据类型的作用，并且接口也是定义你的代码内部，或你的代码和其他项目代码之间的规则的有效方法。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">One of TypeScript&#39;s core principles is that type-checking focuses on the &#39;shape&#39; that values have. This is sometimes called &quot;duck typing&quot; or &quot;structural subtyping&quot;. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project. 
</p></div><h2 class="section-title"><a name="Our First Interface" class="anchor" href="#Our First Interface"><span class="header-link"></span></a>Our First Interface</h2><div role="item"><p>让我们来看看下面这个简单的例子，来了解接口是如何工作的：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The easiest way to see how interfaces work is to start with a simple example:
</p></div><pre><code class="lang-js">function printLabel(labelledObj: {label: string}) {
  console.log(labelledObj.label);
}

var myObj = {size: 10, label: &quot;Size 10 Object&quot;};
printLabel(myObj);
</code></pre>
<div role="item"><p>类型检查器会检查对&#39;printLabel&#39;的调用。其中&#39;printLabel&#39;方法有一个参数，这个参数需要传入一个对象，并且这个对象要有一个字符类型的&#39;label&#39;属性。注意我们传入的这个对象实际上不仅仅只有&#39;label&#39;属性，但编译器只检查那些被指定的属性，并检查它们的类型是否相符。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The type-checker checks the call to &#39;printLabel&#39;. The &#39;printLabel&#39; function has a single parameter that requires that the object passed in has a property called &#39;label&#39; of type string. Notice that our object actually has more properties than this, but the compiler only checks to that at least the ones required are present and match the types required.
</p></div><div role="item"><p>让我们重写上面的例子，这次我们将使用接口来描述参数要求，即传入的对象要有字符串类型的label属性。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">We can write the same example again, this time using an interface to describe the requirement of having the &#39;label&#39; property that is a string:
</p></div><pre><code class="lang-js">interface LabelledValue {
  label: string;
}

function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}

var myObj = {size: 10, label: &quot;Size 10 Object&quot;};
printLabel(myObj);
</code></pre>
<div role="item"><p>我们可以用这个名为&#39;LabelledValue&#39;的接口来描述我们上文例子的需求。它仍旧表示有一个名为&#39;label&#39;的字符串类型的属性。值得注意的是，与其他编程语言不同，我们不需要明确地说
传给&#39;printLabel&#39;的对象实现了这个接口。这里只关注数据的“形状”。只要我们传给函数的对象满足指定的需求，那这个对象就是被允许的。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The interface &#39;LabelledValue&#39; is a name we can now use to describe the requirement in the previous example. It still represents having a single property called &#39;label&#39; that is of type string. Notice we didn&#39;t have to explicitly say that the object we pass to &#39;printLabel&#39; implements this interface like we might have to in other languages. Here, it&#39;s only the shape that matters. If the object we pass to the function meets the requirements listed, then it&#39;s allowed.
</p></div><div role="item"><p>值得指出的是，类型检查器并不要求这些属性遵循一定的顺序。只要接口要求的属性存在，并符合类型即可。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">It&#39;s worth pointing out that the type-checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type.
</p></div><h2 class="section-title"><a name="Optional Properties" class="anchor" href="#Optional Properties"><span class="header-link"></span></a>Optional Properties</h2><div role="item"><p>一个接口中的属性并不都是必须的。在一定的条件下，有些属性甚至可以完全不存在。在创建像“option bags”这样的模式时，用户传给函数作为参数的对象，往往只包含部分属性在里面。这时候可选属性就很有用了。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Not all properties of an interface may be required. Some exist under certain conditions or may not be there at all. These optional properties are popular when creating patterns like &quot;option bags&quot; where the user passes an object to a function that only has a couple properties filled in.
</p></div><div role="item"><p>下面是这种模式的一个例子：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Here&#39;s as example of this pattern:
</p></div><pre><code class="lang-js">interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  var newSquare = {color: &quot;white&quot;, area: 100};
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

var mySquare = createSquare({color: &quot;black&quot;});
</code></pre>
<div role="item"><p>除了在每个可选属性声明时需要加上&#39;?&#39;作为标识以外，带有可选属性的接口的写法与其他接口相似。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Interfaces with optional properties are written similar to other interfaces, which each optional property denoted with a &#39;?&#39; as part of the property declaration. 
</p></div><div role="item"><p>可选属性的优势在于，我们在描述可能存在的属性的同时，仍可以捕捉到那些我们不希望存在的属性。举例来说，如果我们错误地拼写了传给&#39;createSquare&#39;的属性名，会有一条错误信息提示我们：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The advantage of optional properties is that you can describe these possibly available properties while still also catching properties that you know are not expected to be available. For example, had we mistyped the name of the property we passed to &#39;createSquare&#39;, we would get an error message letting us know:
</p></div><pre><code class="lang-js">interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  var newSquare = {color: &quot;white&quot;, area: 100};
  if (config.color) {
    newSquare.color = config.collor;  // Type-checker can catch the mistyped name here
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

var mySquare = createSquare({color: &quot;black&quot;});
</code></pre>
<h2 class="section-title"><a name="Function Types" class="anchor" href="#Function Types"><span class="header-link"></span></a>Function Types</h2><div role="item"><p>接口可以描述JavaScript对象各式各样的构成。然而除了描述一个对象的属性以外，接口也可以描述函数类型。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Interfaces are capable of describing the wide range of shapes that JavaScript objects can take. In addition to describing an object with properties, interfaces are also capable of describing function types.
</p></div><div role="item"><p>为了用接口来描述函数类型，我们需要给接口一个调用标记。它看起来就像是只有参数列表和返回类型的函数定义。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">To describe a function type with an interface, we give the interface a call signature. This is like a function declaration with only the parameter list and return type given.
</p></div><pre><code class="lang-js">interface SearchFunc {
  (source: string, subString: string): boolean;
}
</code></pre>
<div role="item"><p>一旦定义好了以后，我们就可以像用其他接口一样使用这个函数类型接口。下面展示了如何创建一个函数类型变量并给它赋值一个同样类型的函数值。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Once defined, we can use this function type interface like we would other interfaces. Here, we show how you can create a variable of a function type and assign it a function value of the same type.
</p></div><pre><code class="lang-js">var mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  var result = source.search(subString);
  if (result == -1) {
    return false;
  }
  else {
    return true;
  }
}
</code></pre>
<div role="item"><p>为了能对函数类型进行正确的类型检查，参数名称不需要与接口保持一致。就是说上面的例子也可以这么写：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">For function types to correctly type-check, the name of the parameters do not need to match. We could have, for example, written the above example like this:
</p></div><pre><code class="lang-js">var mySearch: SearchFunc;
mySearch = function(src: string, sub: string) {
  var result = src.search(sub);
  if (result == -1) {
    return false;
  }
  else {
    return true;
  }
}
</code></pre>
<div role="item"><p>在对函数的参数进行类型检查时，同一时间只会检查一个参数是否与其在接口对应位置上的类型一致。而我们的函数表达式的返回类型也会通过其返回值对应的类型进行判断（这里是true和false）。如果这里函数返回的是数字或字符串，那类型检查器就会警告我们返回的类型与SearchFunc接口不相符。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Function parameters are checked one at a time, with the type in each corresponding parameter position checked against each other. Here, also, the return type of our function expression is implied by the values it returns (here false and true). Had the function expression returned numbers or strings, the type-checker would have warned us that return type doesn&#39;t match the return type described in the SearchFunc interface.
</p></div><h2 class="section-title"><a name="Array Types" class="anchor" href="#Array Types"><span class="header-link"></span></a>Array Types</h2><div role="item"><p>我们也可以用接口来描述数组类型，它的声明方式与函数类型相似。数组类型会有一个&#39;index&#39;类型，它用来表示数组的索引（数组下标）的类型，以及索引对应的返回值的类型。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Similarly to how we can use interfaces to describe function types, we can also describe array types. Array types have an &#39;index&#39; type that describes the types allowed to index the object, along with the corresponding return type for accessing the index.
</p></div><pre><code class="lang-js">interface StringArray {
  [index: number]: string;
}

var myArray: StringArray;
myArray = [&quot;Bob&quot;, &quot;Fred&quot;];
</code></pre>
<div role="item"><p>TypeScript支持两种索引类型：string和number。而同时使用两种类型的索引也是可能的，只要我们保证数字类型的索引所对应的值的类型，必须是字符串索引对应的值的类型的子类型。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">There are two types of supported index types: string and number. It is possible to support both types of index, with the restriction that the type returned from the numeric index must be a subtype of the type returned from the string index.
</p></div><div role="item"><p>虽然索引标识是描述数组和字典类型的数据的好方法，它同时也会强迫其他所有属性都与索引的返回类型相同。在下面的例子中，&#39;length&#39;属性的类型不符合索引的返回类型，这会导致类型检查抛出错误：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">While index signatures are a powerful way to describe the array and &#39;dictionary&#39; pattern, they also enforce that all properties match their return type. In this example, the property does not match the more general index, and the type-checker gives an error:
</p></div><pre><code class="lang-js">interface Dictionary {
  [index: string]: string;
  length: number;    // error, the type of &#39;length&#39; is not a subtype of the indexer
}
</code></pre>
<h2 class="section-title"><a name="Class Types" class="anchor" href="#Class Types"><span class="header-link"></span></a>Class Types</h2><h3 class="section-title"><a name="Implementing an interface" class="anchor" href="#Implementing an interface"><span class="header-link"></span></a>Implementing an interface</h3><div role="item"><p>使一个类符合某种特定的约定，是另一种在C#和Java中很常见的接口的使用方式。在TypeScript中我们也可以这样使用接口。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">One of the most common uses of interfaces in languages like C# and Java, that of explicitly enforcing that a class meets a particular contract, is also possible in TypeScript.
</p></div><pre><code class="lang-js">interface ClockInterface {
    currentTime: Date;
}

class Clock implements ClockInterface  {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
</code></pre>
<div role="item"><p>我们可以在一个接口中描述一个类需要实现的方法。就像下面的例子中的&#39;setTime&#39;方法：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">You can also describe methods in an interface that are implemented in the class, as we do with &#39;setTime&#39; in the below example:
</p></div><pre><code class="lang-js">interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface  {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
</code></pre>
<div role="item"><p>接口只能描述类的公共部分，而不关注私有部分。这种机制不允许我们通过接口来检查一个类的实例的私有部分。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Interfaces describe the public side of the class, rather than both the public and private side. This prohibits you from using them to check that a class also has particular types for the private side of the class instance.
</p></div><h3 class="section-title"><a name="Difference between static/instance side of class" class="anchor" href="#Difference between static/instance side of class"><span class="header-link"></span></a>Difference between static/instance side of class</h3><div role="item"><p>当使用类和接口时，我们应该要记得一个类有静态部分和实例特有的部分。你可能注意到了，如果创建一个带有构造函数标记的接口，并尝试创建一个类来实现这个接口的话，我们会收到个错误：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">When working with classes and interfaces, it helps to keep in mind that a class has two types: the type of the static side and the type of the instance side. You may notice that if you create an interface with a construct signature and try to create a class that implements this interface you get an error:
</p></div><pre><code class="lang-js">interface ClockInterface {
    new (hour: number, minute: number);
}

class Clock implements ClockInterface  {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
</code></pre>
<div role="item"><p>这是因为当一个类实现了一个接口，只有实例的部分会被进行检查。构造函数属于静态的部分，它并不在检查的范围之内。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">This is because when a class implements an interface, only the instance side of the class is checked. Since the constructor sits in the static side, it is not included in this check.
</p></div><div role="item"><p>对应地，我们应该直接检查类的静态部分。就像在下面的例子中，我直接检查类本身：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Instead, you would need to work with the &#39;static&#39; side of the class directly. In this example, we work with the class directly:
</p></div><pre><code class="lang-js">interface ClockStatic {
    new (hour: number, minute: number);
}

class Clock  {
    currentTime: Date;
    constructor(h: number, m: number) { }
}

var cs: ClockStatic = Clock;
var newClock = new cs(7, 30);
</code></pre>
<h2 class="section-title"><a name="Extending Interfaces" class="anchor" href="#Extending Interfaces"><span class="header-link"></span></a>Extending Interfaces</h2><div role="item"><p>同类一样，接口也可以相互扩展。扩展机制负责将一个接口中的成员拷贝到另一个接口中，这将允许我们根据自己的意愿把接口分离成可重用的组件。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Like classes, interfaces can extend each other. This handles the task of copying the members of one interface into another, allowing you more freedom in how you separate your interfaces into reusable components.
</p></div><pre><code class="lang-js">interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

var square = &lt;Square&gt;{};
square.color = &quot;blue&quot;;
square.sideLength = 10;
</code></pre>
<div role="item"><p>一个接口可以扩展多个接口，从而形成一个多接口的组合。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">An interface can extend multiple interfaces, creating a combination of all of the interfaces.
</p></div><pre><code class="lang-js">interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

var square = &lt;Square&gt;{};
square.color = &quot;blue&quot;;
square.sideLength = 10;
square.penWidth = 5.0;
</code></pre>
<h2 class="section-title"><a name="Hybrid Types" class="anchor" href="#Hybrid Types"><span class="header-link"></span></a>Hybrid Types</h2><div role="item"><p>就像我们之前提到过的，接口可以描述现实世界中的JavaScript所表现的丰富的数据类型。由于JavaScript动态、灵活的特性，我们有时可能会碰到需要综合使用前面描述的接口的使用方法，来处理一个对象的情景。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">As we mentioned earlier, interfaces can describe the rich types present in real world JavaScript. Because of JavaScript&#39;s dynamic and flexible nature, you may occasionally encounter an object that works as a combination of some of the types described above. 
</p></div><div role="item"><p>举个例子，一个同时可以作为函数，并带有额外属性的对象：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">One such example is an object that acts as both a function and an object, with additional properties:
</p></div><pre><code class="lang-js">interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

var c: Counter;
c(10);
c.reset();
c.interval = 5.0;
</code></pre>
<div role="item"><p>当同第三方JavaScript代码进行交互时，我们可能就需要使用上面的模式，以完整地描述一个数据的类型和结构。#Classes
$Traditional JavaScript focuses on functions and prototype-based inheritance as the basic means of building up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes. Starting with ECMAScript 6, the next version of JavaScript, JavaScript programmers will be able to build their applications using this object-oriented class-based approach. In TypeScript, we allow developers to use these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.
<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">When interacting with 3rd-party JavaScript, you may need to use patterns like the above to fully-describe the shape of the type.
</p></div><h2 class="section-title"><a name="Classes" class="anchor" href="#Classes"><span class="header-link"></span></a>Classes</h2><div role="item"><p>让我们来看一个基于类的简单例子：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Let&#39;s take a look at a simple class-based example:
</p></div><pre><code class="lang-js">class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return &quot;Hello, &quot; + this.greeting;
    }
}

var greeter = new Greeter(&quot;world&quot;);
</code></pre>
<div role="item"><p>如果你曾经使用过C#或Java，那应该对上面的语法很熟悉。我们声明了一个有三个成员的类&#39;Greeter&#39;，即&#39;greeting&#39;属性、构造函数和&#39;greet&#39;方法。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The syntax should look very familiar if you&#39;ve used C# or Java before. We declare a new class &#39;Greeter&#39;. This class has three members, a property called &#39;greeting&#39;, a constructor, and a method &#39;greet&#39;. 
</p></div><div role="item"><p>你会注意到当我们在类中用到某个成员时，我们使用了&#39;this.&#39;前缀，表明了这是一次对类成员的访问。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">You&#39;ll notice that in the class when we refer to one of the members of the class we prepend &#39;this.&#39;. This denotes that it&#39;s a member access.
</p></div><div role="item"><p>代码的最后一行，我们用&#39;new&#39;操作符构建了一个Greeter类的实例。构造过程是：调用我们先前定义的构造函数，创建了一个Greeter类型的新对象，并执行构造函数初始化了这个对象。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">In the last line we construct an instance of the Greeter class using &#39;new&#39;. This calls into the constructor we defined earlier, creating a new object with the Greeter shape, and running the constructor to initialize it.
</p></div><h2 class="section-title"><a name="Inheritance" class="anchor" href="#Inheritance"><span class="header-link"></span></a>Inheritance</h2><div role="item"><p>我们可以在TypeScript中使用常见的面向对象的模式。当然在基于类的编程中，最基本的一个模式便是通过继承来扩展已有的类，以创建新的类。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">In TypeScript, we can use common object-oriented patterns. Of course, one of the most fundamental patterns in class-based programming is being able to extend existing classes to create new ones using inheritance.
</p></div><div role="item"><p>让我们来看一个例子：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Let&#39;s take a look at an example:
</p></div><pre><code class="lang-js">class Animal {
    name:string;
    constructor(theName: string) { this.name = theName; }
    move(meters: number = 0) {
        alert(this.name + &quot; moved &quot; + meters + &quot;m.&quot;);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(meters = 5) {
        alert(&quot;Slithering...&quot;);
        super.move(meters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(meters = 45) {
        alert(&quot;Galloping...&quot;);
        super.move(meters);
    }
}

var sam = new Snake(&quot;Sammy the Python&quot;);
var tom: Animal = new Horse(&quot;Tommy the Palomino&quot;);

sam.move();
tom.move(34);
</code></pre>
<div role="item"><p>这个例子涵盖了不少在其他语言中常见的，同时也属于TypeScript的继承特性。我们看到这里使用了&#39;extends&#39;关键字来创建一个子类。这里的&#39;Horse&#39;和&#39;Snake&#39;继承基类&#39;Animal&#39;并能访问基类的成员。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">This example covers quite a bit of the inheritance features in TypeScript that are common to other languages. Here we see using the &#39;extends&#39; keywords to create a subclass. You can see this where &#39;Horse&#39; and &#39;Snake&#39; subclass the base class &#39;Animal&#39; and gain access to its features.
</p></div><div role="item"><p>这个例子同时也展示了我们可以通过对子类进行专门的定义来重写超类（？）中的方法。这里的&#39;Snake&#39;和&#39;Horse&#39;都创建了一个&#39;move&#39;方法,重写了&#39;Animal&#39;中的&#39;move&#39;方法，从而给予每个类特定的功能。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The example also shows off being able to override methods in the base class with methods that are specialized for the subclass. Here both &#39;Snake&#39; and &#39;Horse&#39; create a &#39;move&#39; method that overrides the &#39;move&#39; from &#39;Animal&#39;, giving it functionality specific to each class.
</p></div><h2 class="section-title"><a name="Private/Public modifiers" class="anchor" href="#Private/Public modifiers"><span class="header-link"></span></a>Private/Public modifiers</h2><h3 class="section-title"><a name="Public by default" class="anchor" href="#Public by default"><span class="header-link"></span></a>Public by default</h3><div role="item"><p>你肯能已经注意到了，在前面的例子中，我们都没有用&#39;public&#39;来使类的成员可见。像是在C#这类的语言中，每个对外部可见的成员都需要我们用&#39;public&#39;进行明确地标识。而在TypeScript中，每个成员都默认为公有的。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">You may have noticed in the above examples we haven&#39;t had to use the word &#39;public&#39; to make any of the members of the class visible. Languages like C# require that each member be explicitly labelled &#39;public&#39; to be visible. In TypeScript, each member is public by default. 
</p></div><div role="item"><p>你仍旧可以通过将成员标识为私有的，以使其对外部不可见。我们可以像下面这样实现前面的&#39;Animal&#39;：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">You may still mark members a private, so you control what is publicly visible outside of your class. We could have written the &#39;Animal&#39; class from the previous section like so:
</p></div><pre><code class="lang-js">class Animal {
    private name:string;
    constructor(theName: string) { this.name = theName; }
    move(meters: number) {
        alert(this.name + &quot; moved &quot; + meters + &quot;m.&quot;);
    }
}
</code></pre>
<h3 class="section-title"><a name="Understanding private" class="anchor" href="#Understanding private"><span class="header-link"></span></a>Understanding private</h3><div role="item"><p>当我们比较两种不同的数据类型时，我们会忽略它们是怎么来的。只要它们的没一个成员都相互兼容，我们就说这两种类型是兼容的。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">TypeScript is a structural type system. When we compare two different types, regardless of where they came from, if the types of each member are compatible, then we say the types themselves are compatible. 
TypeScript是结构性类型系统（structural type system）。
</p></div><div role="item"><p>而当比较拥有私有成员的类型时，情况会稍有不同。当比较两种类型是否兼容时，如果其中一种类型拥有私有成员，那么只有当另一种类型也对应拥有具有相同定义的私有成员时，我们才说这两种类型是兼容的。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">When comparing types that have &#39;private&#39; members, we treat these differently. For two types to be considered compatible, if one of them has a private member, then the other must have a private member that originated in the same declaration. 
</p></div><div role="item"><p>为了更好地理解这是怎么回事，我们可以看看下面的例子：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Let&#39;s look at an example to better see how this plays out in practice:
</p></div><pre><code class="lang-js">class Animal {
    private name:string;
    constructor(theName: string) { this.name = theName; }
}

class Rhino extends Animal {
  constructor() { super(&quot;Rhino&quot;); }
}

class Employee {
    private name:string;
    constructor(theName: string) { this.name = theName; } 
}

var animal = new Animal(&quot;Goat&quot;);
var rhino = new Rhino();
var employee = new Employee(&quot;Bob&quot;);

animal = rhino;
animal = employee; //error: Animal and Employee are not compatible
</code></pre>
<div role="item"><p>在这个例子中，我们有一个&#39;Animal&#39;和一个&#39;Animal&#39;的子类——&#39;Rhino&#39;。同时我们也有一个看起来和&#39;Animal&#39;结构一样的&#39;Employee&#39;。我们生成了这些类的实例并尝试把它们互相赋值给对方，看看会产生什么结果。因为&#39;Animal&#39;和&#39;Rhino&#39;的&#39;private name: string&#39;声明的来源相同，私有部分相同，所以我们说它们是兼容的。而&#39;Employee&#39;的不同。当尝试将一个&#39;Employee&#39;的实例赋值给&#39;Animal&#39;类型的变量时，我们会得到这些类型不兼容的错误。尽管&#39;Employee&#39;同样有一个名为&#39;name&#39;的私有成员，但它不同与&#39;Animal&#39;中的&#39;name&#39;来源不同。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">In this example, we have an &#39;Animal&#39; and a &#39;Rhino&#39;, with &#39;Rhino&#39; being a subclass of &#39;Animal&#39;. We also have a new class &#39;Employee&#39; that looks identical to &#39;Animal&#39; in terms of shape. We create some instances of these classes and then try to assign them to each other to see what will happen. Because &#39;Animal&#39; and &#39;Rhino&#39; share the private side of their shape from the same declaration of &#39;private name: string&#39; in &#39;Animal&#39;, they are compatible. However, this is not the case for &#39;Employee&#39;. When we try to assign from an &#39;Employee&#39; to &#39;Animal&#39; we get an error that these types are not compatible. Even though &#39;Employee&#39; also has a private member called &#39;name&#39;, it is not the same one as the one created in &#39;Animal&#39;. 
</p></div><h3 class="section-title"><a name="Parameter properties" class="anchor" href="#Parameter properties"><span class="header-link"></span></a>Parameter properties</h3><div role="item"><p>&#39;public&#39;和&#39;private&#39;关键字同样也提供给了我们通过创建属性参数，来创建和初始化类的成员的简写的方法。这些属性允许你在一部之内就创建并初始化一个成员。下面是前面例子更进一步的版本。注意这里我们没有用&#39;theName&#39;，而是直接在构造函数里声明了个&#39;private name: string&#39;的参数，并创建和初始化了&#39;name&#39;成员。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The keywords &#39;public&#39; and &#39;private&#39; also give you a shorthand for creating and initializing members of your class, by creating parameter properties. The properties let you can create and initialize a member in one step. Here&#39;s a further revision of the previous example. Notice how we drop &#39;theName&#39; altogether and just use the shortened &#39;private name: string&#39; parameter on the constructor to create and initialize the &#39;name&#39; member.
</p></div><pre><code class="lang-js">class Animal {
    constructor(private name: string) { }
    move(meters: number) {
        alert(this.name + &quot; moved &quot; + meters + &quot;m.&quot;);
    }
}
</code></pre>
<div role="item"><p>这种使用&#39;private&#39;的方法创建并初始化了一个私有成员。使用&#39;public&#39;的方式也是相似的。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Using &#39;private&#39; in this way creates and initializes a private member, and similarly for &#39;public&#39;. 
</p></div><h2 class="section-title"><a name="Accessors" class="anchor" href="#Accessors"><span class="header-link"></span></a>Accessors</h2><div role="item"><p>TypeScript支持用getters/setters作为与对象中的成员进行交互的方式。这是我们获取对象中的成员的好方法。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">TypeScript supports getters/setters as a way of intercepting accesses to a member of an object. This gives you a way of having finer-grained control over how a member is accessed on each object.
</p></div><div role="item"><p>让我们通过&#39;get&#39;和&#39;set&#39;来转化一个类。首先是一个没有getters和setters的例子。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Let&#39;s convert a simple class to use &#39;get&#39; and &#39;set&#39;. First, let&#39;s start with an example without getters and setters.
</p></div><pre><code class="lang-js">class Employee {
    fullName: string;
}

var employee = new Employee();
employee.fullName = &quot;Bob Smith&quot;;
if (employee.fullName) {
    alert(employee.fullName);
}
</code></pre>
<div role="item"><p>虽然允许我们直接任意地设置fullName会很方便，但如果胡乱地设置它的值，这种方式可能反而会给我们来带麻烦。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">While allowing people to randomly set fullName directly is pretty handy, this might get us in trouble if we people can change names on a whim. 
</p></div><div role="item"><p>在下面这个版本的例子中，在允许用户修改雇员的信息之前，我们会检查并确保用户提供了密码。我们是用一个&#39;set&#39;方法替代了直接获取&#39;fullName&#39;的方式，并进行了密码的检查。同时我们也对应地添加了一个&#39;get&#39;方法来保证前面例子的代码在这里也能继续运行。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">In this version, we check to make sure the user has a secret passcode available before we allow them to modify the employee. We do this by replacing the direct access to fullName with a &#39;set&#39; that will check the passcode. We add a corresponding &#39;get&#39; to allow the previous example to continue to work seamlessly.
</p></div><pre><code class="lang-js">var passcode = &quot;secret passcode&quot;;

class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (passcode &amp;&amp; passcode == &quot;secret passcode&quot;) {
            this._fullName = newName;
        }
        else {
            alert(&quot;Error: Unauthorized update of employee!&quot;);
        }
    }
}

var employee = new Employee();
employee.fullName = &quot;Bob Smith&quot;;
if (employee.fullName) {
    alert(employee.fullName);
}
</code></pre>
<div role="item"><p>为了证明我们的存取器确实在检查密码，我们可以尝试修改一下密码。结果我们得到了一个警告，提示我们没有获取和修改employee的权利。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">To prove to ourselves that our accessor is now checking the passcode, we can modify the passcode and see that when it doesn&#39;t match we instead get the alert box warning us we don&#39;t have access to update the employee.
</p></div><div role="item"><p>注意：要使用存取器，我们需要设置编译器以生成ECMAScript 5代码。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Note: Accessors require you to set the compiler to output ECMAScript 5.
</p></div><h2 class="section-title"><a name="Static Properties" class="anchor" href="#Static Properties"><span class="header-link"></span></a>Static Properties</h2><div role="item"><p>到目前为止，我们都在谈论类的实例上的成员，他们只有在被初始化之后才能在对象上被获取。但我们也可以给一个类创建静态成员，这些静态成员在类上就是可见的，而不需要在实例生成后才能获得。在这个例子中，由于&#39;origin&#39;是所有&#39;grids&#39;都具备的一个通用的值，所以我们用&#39;static&#39;来声明&#39;origin&#39;。每一个实例都可以通过在成员名之前加上类的名字来获得静态成员，和&#39;this&#39;很相似。这里我们在获取静态成员时，在前面加上了&#39;Grid.&#39;。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Up to this point, we&#39;ve only talked about the instance members of the class, those that show up on the object when its instantiated. We can also create static members of a class, those that are visible on the class itself rather than on the instances. In this example, we use &#39;static&#39; on the origin, as it&#39;s a general value for all grids. Each instance accesses this value through prepending the name of the class. Similarly to prepending &#39;this.&#39; in front of instance accesses, here we prepend &#39;Grid.&#39; in front of static accesses.
</p></div><pre><code class="lang-js">class Grid {
    static origin = {x: 0, y: 0};
    calculateDistanceFromOrigin(point: {x: number; y: number;}) {
        var xDist = (point.x - Grid.origin.x);
        var yDist = (point.y - Grid.origin.y);
        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
    }
    constructor (public scale: number) { }
}

var grid1 = new Grid(1.0);  // 1x scale
var grid2 = new Grid(5.0);  // 5x scale

alert(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));
alert(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));
</code></pre>
<h2 class="section-title"><a name="Advanced Techniques" class="anchor" href="#Advanced Techniques"><span class="header-link"></span></a>Advanced Techniques</h2><h3 class="section-title"><a name="Constructor functions" class="anchor" href="#Constructor functions"><span class="header-link"></span></a>Constructor functions</h3><div role="item"><p>当你在TypeScript中声明一个类时，你实际上是同时创建了多个定义。其中你第一个创建的便是类生成的实例的类型。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">When you declare a class in TypeScript, you are actually creating multiple declarations at the same time. The first is the type of the instance of the class.
</p></div><pre><code class="lang-js">class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return &quot;Hello, &quot; + this.greeting;
    }
}

var greeter: Greeter;
greeter = new Greeter(&quot;world&quot;);
alert(greeter.greet());
</code></pre>
<div role="item"><p>这里的&#39;var greeter: Greeter&#39;表示我们把greeter当作是Greeter的实例。这么做都快成为习惯面向对象语言的程序员的习性了。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Here, when we say &#39;var greeter: Greeter&#39;, we&#39;re using Greeter as the type of instances of the class Greeter. This is almost second nature to programmers from other object-oriented languages. 
</p></div><div role="item"><p>我们也创建了一个我们称作构造函数的函数。这是当我们&#39;new&#39;一个实例时会被调用的方法。让我们看看前面例子的代码所编译成的JavaScript来看看这实际上是怎么回事。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">We&#39;re also creating another value that we call the constructor function. This is the function that is called when we &#39;new&#39; up instances of the class. To see what this looks like in practice, let&#39;s take a look at the JavaScript created by the above example:
</p></div><pre><code class="lang-js">var Greeter = (function () {
    function Greeter(message) {
        this.greeting = message;
    }
    Greeter.prototype.greet = function () {
        return &quot;Hello, &quot; + this.greeting;
    };
    return Greeter;
})();

var greeter;
greeter = new Greeter(&quot;world&quot;);
alert(greeter.greet());
</code></pre>
<div role="item"><p>这里的&#39;var Greeter&#39;被赋值给了构造函数。当我们使用&#39;new&#39;并运行这个函数时，我们获得了这个类的一个实例。这个构造函数同样也包含了这个类所有的静态成员。我们可以认为每个类都有属于实例的部分和静态的部分。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Here, &#39;var Greeter&#39; is going to be assigned the constructor function. When we call &#39;new&#39; and run this function, we get an instance of the class. The constructor function also contains all of the static members of the class. Another way to think of each class is that there is an instance side and a static side.
</p></div><div role="item"><p>让我们稍微修改一下这个例子，看看会有什么不同：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Let&#39;s modify the example a bit to show this difference:
</p></div><pre><code class="lang-js">class Greeter {
    static standardGreeting = &quot;Hello, there&quot;;
    greeting: string;
    greet() {
        if (this.greeting) {
            return &quot;Hello, &quot; + this.greeting;
        }
        else {
            return Greeter.standardGreeting;
        }
    }
}

var greeter1: Greeter;
greeter1 = new Greeter();
alert(greeter1.greet());

var greeterMaker: typeof Greeter = Greeter;
greeterMaker.standardGreeting = &quot;Hey there!&quot;;
var greeter2:Greeter = new greeterMaker();
alert(greeter2.greet());
</code></pre>
<div role="item"><p>在这个例子中，&#39;greeter1&#39;运行得和之前差不多。我们生成了&#39;Greeter&#39;类的实例并使用了这个实例对象。这种用法我们之前已经见过了。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">In this example, &#39;greeter1&#39; works similarly to before. We instantiate the &#39;Greeter&#39; class, and use this object. This we have seen before.
</p></div><div role="item"><p>接着，我们直接使用这个类。我们创建了一个名为&#39;greeterMaker&#39;的新变量。这个变量上获得的是这个类本身，或者应该说是这个类的构造函数。这里我们用&#39;typeof Greeter&#39;的意义是&quot;给我Greeter类本身的类型&quot;而不是指实例的类型。或者更准确地来讲应该是&quot;给我这个名为Greeter的标识的类型&quot;，即构造函数的类型。Greeter类型（的变量）会包含所有Greeter的静态成员，这些静态成员是在创建Greeter类的实例的构造函数的上面。为了展示这一点，我们在&#39;greeterMaker&#39;上使用&#39;new&#39;来创建&#39;Greeter&#39;的新实例，并像之前那样使用他们。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Next, we then use the class directly. Here we create a new variable called &#39;greeterMaker&#39;. This variable will hold the class itself, or said another way its constructor function. Here we use &#39;typeof Greeter&#39;, that is &quot;give me the type of the Greeter class itself&quot; rather than the instance type. Or, more precisely, &quot;give me the type of the symbol called Greeter&quot;, which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the Greeter class. We show this by using &#39;new&#39; on &#39;greeterMaker&#39;, creating new instances of &#39;Greeter&#39; and invoking them as before.
</p></div><h3 class="section-title"><a name="Using a class as an interface" class="anchor" href="#Using a class as an interface"><span class="header-link"></span></a>Using a class as an interface</h3><div role="item"><p>就像我们前面说过的，一个类的声明会创造两个东西：一种代表这个类的实例的类型和一个构造函数。因为类会创造类型，所以我们可以在接口中使用它们。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">As we said in the previous section, a class declaration creates two things: a type representing instances of the class and a constructor function. Because classes create types, you can use them in the same places you would be able to use interfaces.
</p></div><pre><code class="lang-js">class Point {
    x: number;
    y: number;
}

interface Point3d extends Point {
    z: number;
}

var point3d: Point3d = {x: 1, y: 2, z: 3};
</code></pre>
<h1 class="section-title"><a name="Modules" class="anchor" href="#Modules"><span class="header-link"></span></a>Modules</h1><div role="item"><p>本部分将概述在TypeScript中，用模块来组织代码的各种方式。内容不仅会覆盖内部模块和外部模块，我们还将讨论每种方式应当在何时使用以及如何使用。同时我们也会对如何使用外部模块，以及在TypeScript中使用模块可能会产生的隐患等进阶话题进行讨论。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">This post outlines the various ways to organize your code using modules in TypeScript. We&#39;ll be covering internal and external modules and we&#39;ll discuss when each is appropriate and how to use them. We&#39;ll also go over some advanced topics of how to use external modules, and address some common pitfalls when using modules in TypeScript.
</p></div><h3 class="section-title"><a name="First steps" class="anchor" href="#First steps"><span class="header-link"></span></a>First steps</h3><div role="item"><p>首先让我们从下面这个会被我们通篇使用的程序讲起。我们已经写了一些最简单的字符串验证方法，你平时可能也会用这类方法来检查用户在网页表单上的输入，或是用来检查外部提供的数据的格式。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Let&#39;s start with the program we&#39;ll be using as our example throughout this page. We&#39;ve written a small set of simplistic string validators, like you might use when checking a user&#39;s input on a form in a webpage or checking the format of an externally-provided data file.
</p></div><p><strong>Validators in a single file</strong></p>
<pre><code class="lang-js">interface StringValidator {
    isAcceptable(s: string): boolean;
}

var lettersRegexp = /^[A-Za-z]+$/;
var numberRegexp = /^[0-9]+$/;

class LettersOnlyValidator implements StringValidator {
    isAcceptable(s: string) {
        return lettersRegexp.test(s);
    }
}

class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}

// Some samples to try
var strings = [&#39;Hello&#39;, &#39;98052&#39;, &#39;101&#39;];
// Validators to use
var validators: { [s: string]: StringValidator; } = {};
validators[&#39;ZIP code&#39;] = new ZipCodeValidator();
validators[&#39;Letters only&#39;] = new LettersOnlyValidator();
// Show whether each string passed each validator
strings.forEach(s =&gt; {
    for (var name in validators) {
        console.log(&#39;&quot;&#39; + s + &#39;&quot; &#39; + (validators[name].isAcceptable(s) ? &#39; matches &#39; : &#39; does not match &#39;) + name);
    }
});
</code></pre>
<h3 class="section-title"><a name="Adding Modularity" class="anchor" href="#Adding Modularity"><span class="header-link"></span></a>Adding Modularity</h3><div role="item"><p>当我们添加验证方法时，我们会想要有某种组织我们的代码的方式，好让我们能够追踪我们创建的类型，同时也不用担心与其他对象在命名上有冲突。我们将把我们的对象包裹进一个模块中，而非将它们放在全局环境，取一堆不同的名字。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">As we add more validators, we&#39;re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects. Instead of putting lots of different names into the global namespace, let&#39;s wrap up our objects into a module.
</p></div><div role="item"><p>在这个例子中，我们已经把所有和验证相关的类型都放进了一个称做&#39;Validation&#39;的模块中。为了让这里的接口和类在模块外部也是可见的，我们将export它们。相反的，变量&#39;lettersRegexp&#39;和&#39;numberRegexp&#39;都是验证实现的细节部分，我们将保持它们的非输出的状态，使其在外部不可见。在文件最后的测试代码中，我们在这个模块的外部测试了模块输出的变量和类型，如：Validation.LettersOnlyValidator。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">In this example, we&#39;ve moved all the Validator-related types into a module called Validation. Because we want the interfaces and classes here to be visible outside the module, we preface them with export. Conversely, the variables lettersRegexp and numberRegexp are implementation details, so they are left unexported and will not be visible to code outside the module. In the test code at the bottom of the file, we now need to qualify the names of the types when used outside the module, e.g. Validation.LettersOnlyValidator.
</p></div><p><strong>Modularized Validators</strong></p>
<pre><code class="lang-js">module Validation {
    export interface StringValidator {
        isAcceptable(s: string): boolean;
    }

    var lettersRegexp = /^[A-Za-z]+$/;
    var numberRegexp = /^[0-9]+$/;

    export class LettersOnlyValidator implements StringValidator {
        isAcceptable(s: string) {
            return lettersRegexp.test(s);
        }
    }

    export class ZipCodeValidator implements StringValidator {
        isAcceptable(s: string) {
            return s.length === 5 &amp;&amp; numberRegexp.test(s);
        }
    }
}

// Some samples to try
var strings = [&#39;Hello&#39;, &#39;98052&#39;, &#39;101&#39;];
// Validators to use
var validators: { [s: string]: Validation.StringValidator; } = {};
validators[&#39;ZIP code&#39;] = new Validation.ZipCodeValidator();
validators[&#39;Letters only&#39;] = new Validation.LettersOnlyValidator();
// Show whether each string passed each validator
strings.forEach(s =&gt; {
    for (var name in validators) {
        console.log(&#39;&quot;&#39; + s + &#39;&quot; &#39; + (validators[name].isAcceptable(s) ? &#39; matches &#39; : &#39; does not match &#39;) + name);
    }
});
</code></pre>
<h2 class="section-title"><a name="分割成多个文件(Splitting Across Files)" class="anchor" href="#分割成多个文件(Splitting Across Files)"><span class="header-link"></span></a>分割成多个文件(Splitting Across Files)</h2><div role="item"><p>当我们的应用变大时，我们会想要将代码分割成多个文件，好使其更容易维护。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">As our application grows, we&#39;ll want to split the code across multiple files to make it easier to maintain.
</p></div><div role="item"><p>在这里，我们将验证模块分成了多个文件。尽管这些文件是分散开的，但他们都会像是定义在同一个地方上的代码一样，作用于同一个模块中。因为这些文件之间互有依赖关系，所以我们添加了引用标签来告诉编译器不同文件之间的关系。测试代码没有变化。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Here, we&#39;ve split our Validation module across many files. Even though the files are separate, they can each contribute to the same module and can be consumed as if they were all defined in one place. Because there are dependencies between files, we&#39;ve added reference tags to tell the compiler about the relationships between the files. Our test code is otherwise unchanged.
</p></div><h3 class="section-title"><a name="Multi-file internal modules" class="anchor" href="#Multi-file internal modules"><span class="header-link"></span></a>Multi-file internal modules</h3><p><strong>Validation.ts</strong></p>
<pre><code class="lang-js">module Validation {
    export interface StringValidator {
        isAcceptable(s: string): boolean;
    }
}
</code></pre>
<p><strong>LettersOnlyValidator.ts</strong></p>
<pre><code class="lang-js">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;
module Validation {
    var lettersRegexp = /^[A-Za-z]+$/;
    export class LettersOnlyValidator implements StringValidator {
        isAcceptable(s: string) {
            return lettersRegexp.test(s);
        }
    }
}
</code></pre>
<p><strong>ZipCodeValidator.ts</strong></p>
<pre><code class="lang-js">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;
module Validation {
    var numberRegexp = /^[0-9]+$/;
    export class ZipCodeValidator implements StringValidator {
        isAcceptable(s: string) {
            return s.length === 5 &amp;&amp; numberRegexp.test(s);
        }
    }
}
</code></pre>
<p><strong>Test.ts</strong></p>
<pre><code class="lang-js">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;
/// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt;
/// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt;

// Some samples to try
var strings = [&#39;Hello&#39;, &#39;98052&#39;, &#39;101&#39;];
// Validators to use
var validators: { [s: string]: Validation.StringValidator; } = {};
validators[&#39;ZIP code&#39;] = new Validation.ZipCodeValidator();
validators[&#39;Letters only&#39;] = new Validation.LettersOnlyValidator();
// Show whether each string passed each validator
strings.forEach(s =&gt; {
    for (var name in validators) {
        console.log(&#39;&quot;&#39; + s + &#39;&quot; &#39; + (validators[name].isAcceptable(s) ? &#39; matches &#39; : &#39; does not match &#39;) + name);
    }
});
</code></pre>
<div role="item"><p>当项目有多个文件参与进来时，我们就必须保证所有被编译后的代码都能被加载进来。我们有两种方法来实现这一点。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Once there are multiple files involved, we&#39;ll need to make sure all of the compiled code gets loaded. There are two ways of doing this.
</p></div><div role="item"><p>第一中方法是通过--out flag来将所有输入的文件内容连接起来，并将结果输出到单个JavaScript文件中：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">First, we can use concatenated output using the --out flag to compile all of the input files into a single JavaScript output file:
</p></div><pre><code>tsc --out sample.js Test.ts
</code></pre><div role="item"><p>编译器将会根据出现在文件中的引用标签自动地排序输出文件中的内容。而你也可以手动指定每个文件的顺序：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:
</p></div><pre><code>tsc --out sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts
</code></pre><div role="item"><p>另外，我们也可以使用每个文件分别输出的编译方式（这是默认选项）。生成多个JS文件以后，我们需要在网页上用&lt;script&gt;标签按恰当的顺序加载每个文件，像是下面的例子：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Alternatively, we can use per-file compilation (the default) to emit one JavaScript file for each input file. If multiple JS files get produced, we&#39;ll need to use &lt;script&gt; tags on our webpage to load each emitted file in the appropriate order, for example:
</p></div><p><strong>MyTestPage.html (excerpt)</strong></p>
<pre><code class="lang-html">    &lt;script src=&quot;Validation.js&quot; type=&quot;text/javascript&quot; /&gt;
    &lt;script src=&quot;LettersOnlyValidator.js&quot; type=&quot;text/javascript&quot; /&gt;
    &lt;script src=&quot;ZipCodeValidator.js&quot; type=&quot;text/javascript&quot; /&gt;
    &lt;script src=&quot;Test.js&quot; type=&quot;text/javascript&quot; /&gt;
</code></pre>
<h2 class="section-title"><a name="Going External" class="anchor" href="#Going External"><span class="header-link"></span></a>Going External</h2><div role="item"><p>TypeScript同样也有外部模块的概念。我们会在node.js和require.js的中使用到外部文件。而不使用node.js和require.js的应用则不需要使用外部模块，前面讲述过的内部模块的概念就能够很好地组织起我们的应用。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">TypeScript also has the concept of an external module. External modules are used in two cases: node.js and require.js. Applications not using node.js or require.js do not need to use external modules and can best be organized using the internal module concept outlined above.
</p></div><div role="item"><p>在外部模块中，文件之间的关系是通过文件级别的输入和输出来指定的。在TypeSciprt中，任何包含顶级import和export的文件都被认为是外部模块。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">In external modules, relationships between files are specified in terms of imports and exports at the file level. In TypeScript, any file containing a top-level import or export is considered an external module.
</p></div><div role="item"><p>下面的例子中，我们将前面的例子转换成了使用外部模块的形式。注意这里我们不再使用module关键字，文件本身就构成了一个模块，并由它们的文件名进行定义。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Below, we have converted the previous example to use external modules. Notice that we no longer use the module keyword – the files themselves constitute a module and are identified by their filenames.
</p></div><div role="item"><p>引用标签被指定了依赖的import声明所替代。引用标签由两部分构成：这个模块在这个文件中的名称和用来指定依赖文件路径的require关键字部分。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The reference tags have been replaced with import statements that specify the dependencies between modules. The import statement has two parts: the name that the module will be known by in this file, and the require keyword that specifies the path to the required module:
</p></div><pre><code class="lang-js">import someMod = require(&#39;someModule&#39;);
</code></pre>
<div role="item"><p>与我们是如何用export定义一个内部模块的公共部分相似，这里我们在顶级声明上用export关键字来指定哪些对象是外部可见的。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">We specify which objects are visible outside the module by using the export keyword on a top-level declaration, similarly to how export defined the public surface area of an internal module.
</p></div><div role="item"><p>编译时，我们必须在命令行上指定一个模块。对于node.js来说，要用 --module commonjs；对于require.js来说，要用--module amd。来看下面的例子：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">To compile, we must specify a module target on the command line. For node.js, use --module commonjs; for require.js, use --module amd. For example:
</p></div><pre><code>tsc --module commonjs Test.ts
</code></pre><div role="item"><p>编译以后，每个外部模块都会变成一个分离的.js文件。和引用标签相似，编译器会根据import声明来编译相互依赖的文件。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">When compiled, each external module will become a separate .js file. Similar to reference tags, the compiler will follow import statements to compile dependent files.
</p></div><p><strong>Validation.ts</strong></p>
<pre><code class="lang-js">export interface StringValidator {
    isAcceptable(s: string): boolean;
}
</code></pre>
<p><strong>LettersOnlyValidator.ts</strong></p>
<pre><code class="lang-js">import validation = require(&#39;./Validation&#39;);
var lettersRegexp = /^[A-Za-z]+$/;
export class LettersOnlyValidator implements validation.StringValidator {
    isAcceptable(s: string) {
        return lettersRegexp.test(s);
    }
}
</code></pre>
<p><strong>ZipCodeValidator.ts</strong></p>
<pre><code class="lang-js">import validation = require(&#39;./Validation&#39;);
var numberRegexp = /^[0-9]+$/;
export class ZipCodeValidator implements validation.StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}
</code></pre>
<p><strong>Test.ts</strong></p>
<pre><code class="lang-js">import validation = require(&#39;./Validation&#39;);
import zip = require(&#39;./ZipCodeValidator&#39;);
import letters = require(&#39;./LettersOnlyValidator&#39;);

// Some samples to try
var strings = [&#39;Hello&#39;, &#39;98052&#39;, &#39;101&#39;];
// Validators to use
var validators: { [s: string]: validation.StringValidator; } = {};
validators[&#39;ZIP code&#39;] = new zip.ZipCodeValidator();
validators[&#39;Letters only&#39;] = new letters.LettersOnlyValidator();
// Show whether each string passed each validator
strings.forEach(s =&gt; {
    for (var name in validators) {
        console.log(&#39;&quot;&#39; + s + &#39;&quot; &#39; + (validators[name].isAcceptable(s) ? &#39; matches &#39; : &#39; does not match &#39;) + name);
    }
});
</code></pre>
<h3 class="section-title"><a name="Code Generation for External Modules" class="anchor" href="#Code Generation for External Modules"><span class="header-link"></span></a>Code Generation for External Modules</h3><div role="item"><p>编译器会根据编译时指定的模块，而为node.js (commonjs)或require.js (AMD)生成合适的，用于模块加载系统的代码。如果想要了解更多这些生成的，用于定义和依赖的代码到底做了什么的话，你可以查看每个模块加载器的文档。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Depending on the module target specified during compilation, the compiler will generate appropriate code for either node.js (commonjs) or require.js (AMD) module-loading systems. For more information on what the define and require calls in the generated code do, consult the documentation for each module loader.
</p></div><div role="item"><p>下面这个例子展示了在import和export阶段所使用的名称是如何被翻译成其他模块加载其的代码的。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">This simple example shows how the names used during importing and exporting get translated into the module loading code.
</p></div><p><strong>SimpleModule.ts</strong></p>
<pre><code class="lang-js">import m = require(&#39;mod&#39;);
export var t = m.something + 1;
</code></pre>
<p><strong>AMD / RequireJS SimpleModule.js:</strong></p>
<pre><code class="lang-js">define([&quot;require&quot;, &quot;exports&quot;, &#39;mod&#39;], function(require, exports, m) {
    exports.t = m.something + 1;
});
</code></pre>
<p><strong>CommonJS / Node SimpleModule.js:</strong></p>
<pre><code class="lang-js">var m = require(&#39;mod&#39;);
exports.t = m.something + 1;
</code></pre>
<h2 class="section-title"><a name="Export =" class="anchor" href="#Export ="><span class="header-link"></span></a>Export =</h2><div role="item"><p>在前面的例子中，每次我们输出一个validator时，每个模块都只暴露出一个值。而实际上对于这种一个模块只要输出一个值情况，这样的做法是十分笨重的。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">In the previous example, when we consumed each validator, each module only exported one value. In cases like this, it&#39;s cumbersome to work with these symbols through their qualified name when a single identifier would do just as well.
</p></div><div role="item"><p>&quot;export =&quot;的句法可以指定一个模块要输出的一个对象。这个对象可以是个类，也可以是接口，模块，函数或是枚举类型。而当这个模块被输入时，模块输出的内容就可以被直接使用，而不需要再加上任何（模块）名称。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The export = syntax specifies a single object that is exported from the module. This can be a class, interface, module, function, or enum. When imported, the exported symbol is consumed directly and is not qualified by any name.
</p></div><div role="item"><p>下面的例子中，我们用&quot;export =&quot;句法简化了前面Validator的实现，每个模块只会输出一个对象。这样的做法简化了使用模块的代码——我们可以直接引用&#39;zipValidator&#39;而不需要用&#39;zip.ZipCodeValidator&#39;。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Below, we&#39;ve simplified the Validator implementations to only export a single object from each module using the export = syntax. This simplifies the consumption code – instead of referring to &#39;zip.ZipCodeValidator&#39;, we can simply refer to &#39;zipValidator&#39;.
</p></div><p><strong>Validation.ts</strong></p>
<pre><code class="lang-js">export interface StringValidator {
    isAcceptable(s: string): boolean;
}
</code></pre>
<p><strong>LettersOnlyValidator.ts</strong></p>
<pre><code class="lang-js">import validation = require(&#39;./Validation&#39;);
var lettersRegexp = /^[A-Za-z]+$/;
class LettersOnlyValidator implements validation.StringValidator {
    isAcceptable(s: string) {
        return lettersRegexp.test(s);
    }
}
export = LettersOnlyValidator;
</code></pre>
<p><strong>ZipCodeValidator.ts</strong></p>
<pre><code class="lang-js">import validation = require(&#39;./Validation&#39;);
var numberRegexp = /^[0-9]+$/;
class ZipCodeValidator implements validation.StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}
export = ZipCodeValidator;
</code></pre>
<p><strong>Test.ts</strong></p>
<pre><code class="lang-js">import validation = require(&#39;./Validation&#39;);
import zipValidator = require(&#39;./ZipCodeValidator&#39;);
import lettersValidator = require(&#39;./LettersOnlyValidator&#39;);

// Some samples to try
var strings = [&#39;Hello&#39;, &#39;98052&#39;, &#39;101&#39;];
// Validators to use
var validators: { [s: string]: validation.StringValidator; } = {};
validators[&#39;ZIP code&#39;] = new zipValidator();
validators[&#39;Letters only&#39;] = new lettersValidator();
// Show whether each string passed each validator
strings.forEach(s =&gt; {
    for (var name in validators) {
        console.log(&#39;&quot;&#39; + s + &#39;&quot; &#39; + (validators[name].isAcceptable(s) ? &#39; matches &#39; : &#39; does not match &#39;) + name);
    }
});
</code></pre>
<h2 class="section-title"><a name="Alias" class="anchor" href="#Alias"><span class="header-link"></span></a>Alias</h2><div role="item"><p>另一种用模块简化我们工作的方式是用&quot;import q = x.y.z&quot;来为对象创建短一些的名称。&quot;import q = x.y.z&quot;和用于加载外部模块的&quot;import x = require(&#39;name&#39;)&quot;是不一样的，它只会为指定的符号创建一个别名。我们可以将这类import（通常只是被引用作为别名）用于任何类型标识符上，包括从外部模块的输入中创建的对象。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Another way that you can simplify working with either kind of module is to use import q = x.y.z to create shorter names for commonly-used objects. Not to be confused with the import x = require(&#39;name&#39;) syntax used to load external modules, this syntax simply creates an alias for the specified symbol. You can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects created from external module imports.
</p></div><p><strong>Basic Aliasing</strong></p>
<pre><code class="lang-js">module Shapes {
    export module Polygons {
        export class Triangle { }
        export class Square { }
    }
}

import polygons = Shapes.Polygons;
var sq = new polygons.Square(); // Same as &#39;new Shapes.Polygons.Square()&#39;
</code></pre>
<div role="item"><p>注意我们不使用require关键字，而是直接赋值为我们输入的限定名的符号。这和变量的使用方式相似，但它同时也对数据类型以及起命名空间作用的输入符号起作用。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Notice that we don&#39;t use the require keyword; instead we assign directly from the qualified name of the symbol we&#39;re importing. This is similar to using var, but also works on the type and namespace meanings of the imported symbol. Importantly, for values, import is a distinct reference from the original symbol, so changes to an aliased var will not be reflected in the original variable.
</p></div><h2 class="section-title"><a name="Optional Module Loading and Other Advanced Loading Scenarios" class="anchor" href="#Optional Module Loading and Other Advanced Loading Scenarios"><span class="header-link"></span></a>Optional Module Loading and Other Advanced Loading Scenarios</h2><div role="item"><p>在某些场景下，你可能需要在某些条件成立的情况下再加载某一个模块。在TypeScript中，我们可以用后面展示的方式，在保障数据类型保持安全的前提下，直接触发模块加载器，以满足这种需求及其他特殊的模块加载场景。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">In some cases, you may want to only load a module under some conditions. In TypeScript, we can use the pattern shown below to implement this and other advanced loading scenarios to directly invoke the module loaders without losing type safety.
</p></div><div role="item"><p>编译器会检测在生成的JavaScript中，是否每个模块都被用到了。对于那些只会作用于类型系统的模块来说，我们并不需要调用require。这种挑选出未被使用的引用的做法对性能大有脾益，并且也允许我们加载这些可选的模块（?）。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The compiler detects whether each module is used in the emitted JavaScript. For modules that are only used as part of the type system, no require calls are emitted. This culling of unused references is a good performance optimization, and also allows for optional loading of those modules.
</p></div><div role="item"><p>这一模式的核心思想在于用import id = require(&#39;...&#39;)获取外部模块暴露出来的类型。就像下面的if语句块那样，模块加载器会被（require）动态触发。由于模块只有在被需要时才会被加载，所以这种做法能够充分发挥reference-culling对性能的提升作用。而要让这种模式能够起作用，关键在于保证我们用import定义的标识只用在类型上（即编译时不会生成JavaScript代码）。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The core idea of the pattern is that the import id = require(&#39;...&#39;) statement gives us access to the types exposed by the external module. The module loader is invoked (through require) dynamically, as shown in the if blocks below. This leverages the reference-culling optimization so that the module is only loaded when needed. For this pattern to work, it&#39;s important that the symbol defined via import is only used in type positions (i.e. never in a position that would be emitted into the JavaScript).
</p></div><div role="item"><p>我们可以用typeof关键字来保证类型的安全。用在类型位置上的typeof关键字会生成一个值对应的类型，在这个例子中对应的是外部模块的类型。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">To maintain type safety, we can use the typeof keyword. The typeof keyword, when used in a type position, produces the type of a value, in this case the type of the external module.
</p></div><p><strong>Dynamic Module Loading in node.js</strong></p>
<pre><code class="lang-js">declare var require;
import Zip = require(&#39;./ZipCodeValidator&#39;);
if (needZipValidation) {
    var x: typeof Zip = require(&#39;./ZipCodeValidator&#39;);
    if (x.isAcceptable(&#39;.....&#39;)) { /* ... */ }
}
</code></pre>
<p><strong>Sample: Dynamic Module Loading in require.js</strong></p>
<pre><code class="lang-js">declare var require;
import Zip = require(&#39;./ZipCodeValidator&#39;);
if (needZipValidation) {
    require([&#39;./ZipCodeValidator&#39;], (x: typeof Zip) =&gt; {
        if (x.isAcceptable(&#39;...&#39;)) { /* ... */ }
    });
}
</code></pre>
<h2 class="section-title"><a name="Working with Other JavaScript Libraries" class="anchor" href="#Working with Other JavaScript Libraries"><span class="header-link"></span></a>Working with Other JavaScript Libraries</h2><div role="item"><p>为了描述非TypeScript的库的数据的类型，我们需要声明这个库所暴露出来的API。因为大多数JavaScript的库只会暴露出来一些顶层的对象，所以用模块的形式来表示这些库是很合适的。我们在声明的时候，并没有定义一个实现环境。通常这些都被定义在.d.ts的文件中。如果你对C/C++很熟悉的话，你可以把它们当作是.h文件或是&quot;外部的&quot; 。接下来让我们来看一些内部模块和外部模块的例子。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes. Because most JavaScript libraries expose only a few top-level objects, modules are a good way to represent them. We call declarations that don&#39;t define an implementation &quot;ambient&quot;. Typically these are defined in .d.ts files. If you&#39;re familiar with C/C++, you can think of these as .h files or &#39;extern&#39;. Let&#39;s look at a few examples with both internal and external examples.
</p></div><h3 class="section-title"><a name="Ambient Internal Modules" class="anchor" href="#Ambient Internal Modules"><span class="header-link"></span></a>Ambient Internal Modules</h3><div role="item"><p>很流行的库D3把它的功能都定义在了一个名为&#39;D3&#39;的全局对象中。由于这个库是通过一个script标签加载进来的（而不是通过模块加载器），它的声明使用了内部模块来定义它的结构。我们用一个ambient内部模块声明来让TypeScript的编译器可以了解它的结构。举个例子：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The popular library D3 defines its functionality in a global object called &#39;D3&#39;. Because this library is loaded through a script tag (instead of a module loader), its declaration uses internal modules to define its shape. For the TypeScript compiler to see this shape, we use an ambient internal module declaration. For example:
</p></div><p><strong>D3.d.ts (simplified excerpt)</strong></p>
<pre><code class="lang-js">declare module D3 {
    export interface Selectors {
        select: {
            (selector: string): Selection;
            (element: EventTarget): Selection;
        };
    }

    export interface Event {
        x: number;
        y: number;
    }

    export interface Base extends Selectors {
        event: Event;
    }
}

declare var d3: D3.Base;
</code></pre>
<h3 class="section-title"><a name="Ambient External Modules" class="anchor" href="#Ambient External Modules"><span class="header-link"></span></a>Ambient External Modules</h3><div role="item"><p>node.js中的大多数的任务是通过加载一个或多个模块来完成的。虽然我们可以在每个文件对应的.d.ts文件中，用顶层输出声明定义这个模块，但把他们写成一个更大的.d.ts文件会更简洁。我们会使用模块的引用名称来实现这一点，这个名称可以在后面的import中使用。举个例子：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">In node.js, most tasks are accomplished by loading one or more modules. We could define each module in its own .d.ts file with top-level export declarations, but it&#39;s more convenient to write them as one larger .d.ts file. To do so, we use the quoted name of the module, which will be available to a later import. For example:
</p></div><p><strong>node.d.ts (simplified excerpt)</strong></p>
<pre><code class="lang-js">declare module &quot;url&quot; {
    export interface Url {
        protocol?: string;
        hostname?: string;
        pathname?: string;
    }

    export function parse(urlStr: string, parseQueryString?, slashesDenoteHost?): Url;
}

declare module &quot;path&quot; {
    export function normalize(p: string): string;
    export function join(...paths: any[]): string;
    export var sep: string;
}
</code></pre>
<div role="item"><p>现在我们可以用&quot;/// <reference>&quot;来引用node.d.ts并用import url = require(&#39;url&#39;)来读取模块。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Now we can /// <reference> node.d.ts and then load the modules using e.g. import url = require(&#39;url&#39;);.
</p></div><pre><code class="lang-js">///&lt;reference path=&quot;node.d.ts&quot;/&gt;
import url = require(&quot;url&quot;);
var myUrl = url.parse(&quot;http://www.typescriptlang.org&quot;);
</code></pre>
<h2 class="section-title"><a name="Pitfalls of Modules" class="anchor" href="#Pitfalls of Modules"><span class="header-link"></span></a>Pitfalls of Modules</h2><div role="item"><p>我们将在这一部分讲述使用内部模块和外部模块时常见的误区，以及如何避免它们。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">In this section we&#39;ll describe various common pitfalls in using internal and external modules, and how to avoid them.
</p></div><h3 class="section-title"><a name="/// <reference> to an external module" class="anchor" href="#/// <reference> to an external module"><span class="header-link"></span></a>/// <reference> to an external module</h3><div role="item"><p>试图用&quot;/// <reference>&quot;句法来引用一个外部模块的文件而不使用import是一种常见的错误。为了理解它们之间的差异，我们首先需要了解编译器定位一个外部模块中的类型信息的三种方式。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">A common mistake is to try to use the /// <reference> syntax to refer to an external module file, rather than using import. To understand the distinction, we first need to understand the three ways that the compiler can locate the type information for an external module.
</p></div><div role="item"><p>第一种方式是通过&quot;import x = require(...);&quot;声明查找对应的.ts文件。这个文件应该是个有具体实现的文件，并在顶层有import和export声明。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The first is by finding a .ts file named by an import x = require(...); declaration. That file should be an implementation file with top-level import or export declarations.
</p></div><div role="item"><p>第二种方式是查找一个.d.ts文件。这种做法与第一种做法相似，但这个文件是个声明文件（同样有顶层的import或export声明），它没有具体的实现的代码。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The second is by finding a .d.ts file, similar to above, except that instead of being an implementation file, it&#39;s a declaration file (also with top-level import or export declarations).
</p></div><div role="item"><p>最后一种方式是查看一个&quot;ambient外部文件声明&quot;。它用一个配对的引用名称&#39;声明&#39;了一个模块。
<strong>myModules.d.ts</strong><span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The final way is by seeing an &quot;ambient external module declaration&quot;, where we &#39;declare&#39; a module with a matching quoted name.
</p></div><pre><code class="lang-js">// In a .d.ts file or .ts file that is not an external module:
declare module &quot;SomeModule&quot; {
    export function fn(): string;
}
</code></pre>
<p><strong>myOtherModule.ts</strong></p>
<pre><code class="lang-js">/// &lt;reference path=&quot;myModules.d.ts&quot; /&gt;
import m = require(&quot;SomeModule&quot;);
</code></pre>
<div role="item"><p>这里的引用标签允许我们定位包含这个ambient外部模块的声明的声明文件。这是不少TypeScript样例中的node.d.ts文件的用法。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The reference tag here allows us to locate the declaration file that contains the declaration for the ambient external module. This is how the node.d.ts file that several of the TypeScript samples use is consumed, for example.
</p></div><h3 class="section-title"><a name="Needless Namespacing" class="anchor" href="#Needless Namespacing"><span class="header-link"></span></a>Needless Namespacing</h3><div role="item"><p>如果你想把一个程序从内部模块转换成外部模块，你很有可能会把文件写成这个样子：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">If you&#39;re converting a program from internal modules to external modules, it can be easy to end up with a file that looks like this:
</p></div><p><strong>shapes.ts</strong></p>
<pre><code class="lang-js">export module Shapes {
    export class Triangle { /* ... */ }
    export class Square { /* ... */ }
}
</code></pre>
<div role="item"><p>在这个顶层模块中，用Shapes包裹起Triangle和Square是没有必要的。因为这对于你的模块的使用者来说会很费解和麻烦：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The top-level module here Shapes wraps up Triangle and Square for no reason. This is confusing and annoying for consumers of your module:
</p></div><p><strong>shapeConsumer.ts</strong></p>
<pre><code class="lang-js">import shapes = require(&#39;./shapes&#39;);
var t = new shapes.Shapes.Triangle(); // shapes.Shapes?
</code></pre>
<div role="item"><p>TypeScript中的外部模块的一个重要的特性，是两个不同的外部模块永远不会让名称声明到同一个作用域上。因为外部模块的用户可以决定使用这个模块时的名称。所以你没有必要事先把要暴露出来的标识用一个命名空间包裹起来。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">A key feature of external modules in TypeScript is that two different external modules will never contribute names to the same scope. Because the consumer of an external module decides what name to assign it, there&#39;s no need to proactively wrap up the exported symbols in a namespace.
</p></div><div role="item"><p>这里重申一下为什么我们不应该给外部模块的内容一个命名空间。命名空间是为了提供一个有逻辑意义的分组结构，并防止命名冲突。因为外部模块文件本身就已经是根据逻辑进行分组的了，并且它顶层的名称也是由输入它的代码所定义的，所以我们没有必要在输出对象时给他加一个额外的模块层。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">To reiterate why you shouldn&#39;t try to namespace your external module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions. Because the external module file itself is already a logical grouping, and its top-level name is defined by the code that imports it, it&#39;s unnecessary to use an additional module layer for exported objects.
</p></div><div role="item"><p>修改后的例子：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Revised Example:
</p></div><p><strong>shapes.ts</strong></p>
<pre><code class="lang-js">export class Triangle { /* ... */ }
export class Square { /* ... */ }
</code></pre>
<p><strong>shapeConsumer.ts</strong></p>
<pre><code class="lang-js">import shapes = require(&#39;./shapes&#39;);
var t = new shapes.Triangle();
</code></pre>
<h3 class="section-title"><a name="Trade-offs for External Modules" class="anchor" href="#Trade-offs for External Modules"><span class="header-link"></span></a>Trade-offs for External Modules</h3><div role="item"><p>就像JS文件和模块之间有一一对应的关系那样，TypeScript的外部模块的源码文件和它们生成的JS文件之间也有一一对应的关系。而这中做法所带来的一个影响就是，我们不可能用--out的编译器开关把多个外部文件源码编译连接进同一个JavaScript文件中去。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between external module source files and their emitted JS files. One effect of this is that it&#39;s not possible to use the --out compiler switch to concatenate multiple external module source files into a single JavaScript file.
</p></div><h1 class="section-title"><a name="Functions" class="anchor" href="#Functions"><span class="header-link"></span></a>Functions</h1><div role="item"><p>函数是构建JavaScript应用的基础。通过函数，我们可以把我们的业务逻辑抽象成多层，或是模仿类的行为，或是信息的隐藏，或是构建模块。虽然在TypeScript中已经有了类和模块，但在描述事物的执行过程时，函数仍旧起着关键的作用。TypeScript给标准的JavaScript函数添加了新的特性好让我们能更好地使用它们。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Functions are the fundamental building block of any applications in JavaScript. They&#39;re how you build up layers of abstraction, mimicking classes, information hiding, and modules. In TypeScript, while there are classes and modules, function still play the key role in describing how to &#39;do&#39; things. TypeScript also adds some new capabilities to the standard JavaScript functions to make them easier to work with.
</p></div><h2 class="section-title"><a name="Functions" class="anchor" href="#Functions"><span class="header-link"></span></a>Functions</h2><div role="item"><p>首先，TypeScript和在JavaScript中一样，既可以创建有名称的函数也可以创建匿名函数。这允许我们选择实现应用的最好方式。你既可以在API中生成一堆函数，也可以构建个一次性的函数，之后再把它替换成另一个函数。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">To begin, just as in JavaScript, TypeScript functions can be created both as a named function or as an anonymous function. This allows you to choose the most appropriate approach for your application, whether you&#39;re building a list of functions in an API or a one-off function to hand off to another function.
</p></div><div role="item"><p>让我们看看这两种方式在JavaScript中的样子：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">To quickly recap what these two approaches look like in JavaScript:
</p></div><pre><code class="lang-js">//Named function
function add(x, y) {
    return x+y;
}

//Anonymous function
var myAdd = function(x, y) { return x+y; };
</code></pre>
<div role="item"><p>和JavaScript中一样，函数可以获得函数体外的变量。当它们获得了函数体外的变量时，我们说函数&#39;捕获&#39;了这些变量。虽然这一机制的工作方式以及它的副作用的这些内容可能超出了本文的范围，但清楚地认识这一机制对我们使用JavaScript和TypeScript来说是很重要的一部分。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Just as in JavaScript, functions can return to variables outside of the function body. When they do so, they&#39;re said to &#39;capture&#39; these variables. While understanding how this works, and the trade-offs when using this technique, are outside of the scope of this article, having a firm understanding how this mechanic is an important piece of working with JavaScript and TypeScript. 
</p></div><pre><code class="lang-js">var z = 100;

function addToZ(x, y) {
    return x+y+z;
}
</code></pre>
<h2 class="section-title"><a name="Function Types" class="anchor" href="#Function Types"><span class="header-link"></span></a>Function Types</h2><h3 class="section-title"><a name="Typing the function" class="anchor" href="#Typing the function"><span class="header-link"></span></a>Typing the function</h3><div role="item"><p>让我们给前面的例子加上类型：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Let&#39;s add types to our simple examples from earlier:
</p></div><pre><code class="lang-js">function add(x: number, y: number): number {
    return x+y;
}

var myAdd = function(x: number, y: number): number { return x+y; };
</code></pre>
<div role="item"><p>我们可以给每个参数和函数的返回值指定类型。TypeScript可以通过返回的语句知道返回值的类型。当然在很多情况下，我们也可以不指定类型。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">We can add types to each of the parameters and then to the function itself to add a return type. TypeScript can figure the return type out by looking at the return statements, so we can also optionally leave this off in many cases.
</p></div><h3 class="section-title"><a name="Writing the function type" class="anchor" href="#Writing the function type"><span class="header-link"></span></a>Writing the function type</h3><div role="item"><p>既然我们已经给函数标记上了类型，那么现在让我们完整地写出这个函数各个部分的类型：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Now that we&#39;ve typed the function, let&#39;s write the full type of the function out by looking at the each piece of the function type. 
</p></div><pre><code class="lang-js">var myAdd: (x:number, y:number)=&gt;number = 
    function(x: number, y: number): number { return x+y; };
</code></pre>
<div role="item"><p>一个函数上的类型包含两个部分：参数的类型和返回值的类型。如果我们要写出函数的完整的类型的话，那这两部分都将是必要的。我们给每个参数一个名称和类型，就像参数列表一样写出它们。参数的名称只是为了程序的可读性，我们也可以这么写上面的例子：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">A function&#39;s type has the same two parts: the type of the arguments and the return type. When writing out the whole function type, both parts are required. We write out the parameter types just like a parameter list, giving each parameter a name and a type. This name is just to help with readability. We could have instead written:
</p></div><pre><code class="lang-js">var myAdd: (baseValue:number, increment:number)=&gt;number = 
    function(x: number, y: number): number { return x+y; };
</code></pre>
<div role="item"><p>不管你给函数的参数取了什么名字，只要这个参数的类型出现了的话，它对函数来说就是有效的。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">As long as the parameter types line up, it&#39;s considered a valid type for the function, regardless of the names you give the parameters in the function type. 
</p></div><div role="item"><p>再来看看返回值的类型。我们通过在参数和返回值的类型之间使用&#39;=&gt;&#39;符号来指定一个函数返回值的类型。如果一个函数不返回值的话，那你需要使用&#39;void&#39;类型。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The second part is the return type. We make it clear which is the return type by using a fat arrow (=&gt;) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn&#39;t return a value, you would use &#39;void&#39; instead of leaving it off.
</p></div><div role="item"><p>记住，参数类型和返回值的类型共同构成了函数的类型。函数中被捕获的变量并不会影响函数的类型。这些变量实际上是被当作函数的&#39;隐藏状态&#39;，它们并不会成为函数API的一部分。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Of note, only the parameters and the return type make up the function type. Captured variables are not reflected in the type. In effect, captured variables are part of the &#39;hidden state&#39; of any function and do not make up its API.
</p></div><h3 class="section-title"><a name="Inferring the types" class="anchor" href="#Inferring the types"><span class="header-link"></span></a>Inferring the types</h3><div role="item"><p>通过前面的例子你可能注意到了，虽然等号的一边有指定类型而另一边没有，但TypeScript的编译器仍能够理解这二者的类型。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">In playing with the example, you may notice that the TypeScript compiler can figure out the type if you have types on one side of the equation but not the other:
</p></div><pre><code class="lang-js">// myAdd has the full function type
var myAdd = function(x: number, y: number): number { return x+y; };

// The parameters &#39;x&#39; and &#39;y&#39; have the type number
var myAdd: (baseValue:number, increment:number)=&gt;number = 
    function(x, y) { return x+y; };
</code></pre>
<div role="item"><p>这被称作&#39;语境类型&#39;（&#39;contextual typing&#39;）。它是一种类型推测，有助于帮助减少我们用于维持类型的工作。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">This is called &#39;contextual typing&#39;, a form of type inference. This helps cut down on the amount of effort to keep your program typed.
</p></div><h2 class="section-title"><a name="Optional and Default Parameters" class="anchor" href="#Optional and Default Parameters"><span class="header-link"></span></a>Optional and Default Parameters</h2><div role="item"><p>与JavaScript不同，TypeScript中函数的每个参数都被假设为是必须的。这并不是说参数的值不能是&#39;null&#39;，但当一个函数被调用时，编译器会检查用户提供的参数。编译器同样也会假设这些参数是传入函数的唯一参数。简而言之，我们必须保证传给函数的参数的数量和函数指定的参数数量是一致的。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Unlike JavaScript, in TypeScript every parameter to a function is assumed to be required by the function. This doesn&#39;t mean that it isn&#39;t a &#39;null&#39; value, but rather, when the function is called the compiler will check that the user has provided a value for each parameter. The compiler also assumes that these parameters are the only parameters that will be passed to the function. In short, the number of parameters to the function has to match the number of parameters the function expects.
</p></div><pre><code class="lang-js">function buildName(firstName: string, lastName: string) {
    return firstName + &quot; &quot; + lastName;
}

var result1 = buildName(&quot;Bob&quot;);  //error, too few parameters
var result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;);  //error, too many parameters
var result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;);  //ah, just right
</code></pre>
<div role="item"><p>在JavaScript中，每个参数被认为是可选的。用户可以按照自己的意愿去掉一部分参数，而没有被传入的参数会被当成是undefined。在TypeScript中，我们可以在一个参数的旁边使用&#39;?&#39;符号来指定这个参数是可选的。举例来说，如果我们想要last name是可选的话：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">In JavaScript, every parameter is considered optional, and users may leave them off as they see fit. When they do, they&#39;re assumed to be undefined. We can get this functionality in TypeScript by using the &#39;?&#39; beside parameters we want optional. For example, let&#39;s say we want the last name to be optional:
</p></div><pre><code class="lang-js">function buildName(firstName: string, lastName?: string) {
    if (lastName)
        return firstName + &quot; &quot; + lastName;
    else
        return firstName;
}

var result1 = buildName(&quot;Bob&quot;);  //works correctly now
var result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;);  //error, too many parameters
var result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;);  //ah, just right
</code></pre>
<div role="item"><p>可选参数必须放在必选参数的后面。前面的例子中，如果我们想要first name是可选的，last name是必须的的话，我们就需要把first name放在后面。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Optional parameters must follow required parameters. Had we wanted to make the first name optional rather than the last name, we would need to change the order of parameters in the function, putting the first name last in the list.
</p></div><div role="item"><p>在TypeScript中，当用户没有传入一个参数时，我们也可以设置一个值来作为这个参数的默认值。这种参数被称作默认参数（default parameters）。下面的例子把前面例子中的last name的默认值改为了&quot;Smith&quot;。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">In TypeScript, we can also set up a value that an optional parameter will have if the user does not provide one. These are called default parameters. Let&#39;s take the previous example and default the last name to &quot;Smith&quot;.
</p></div><pre><code class="lang-js">function buildName(firstName: string, lastName = &quot;Smith&quot;) {
    return firstName + &quot; &quot; + lastName;
}

var result1 = buildName(&quot;Bob&quot;);  //works correctly now, also
var result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;);  //error, too many parameters
var result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;);  //ah, just right
</code></pre>
<div role="item"><p>和可选参数一样，默认参数必须出现在必选参数的后面。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Just as with optional parameters, default parameters must come after required parameters in the parameter list. 
</p></div><div role="item"><p>可选参数和默认参数会共享数据类型。下面的：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Optional parameters and default parameters also share what the type looks like. Both:
</p></div><pre><code class="lang-js">function buildName(firstName: string, lastName?: string) {
</code></pre>
<div role="item"><p>和<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">and
</p></div><pre><code class="lang-js">function buildName(firstName: string, lastName = &quot;Smith&quot;) {
</code></pre>
<div role="item"><p>享有同样的类型&quot;(firstName: string, lastName?: string)=&gt;string&quot;。默认参数的的默认值不会生效，它表明了这个参数是可选的。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">share the same type &quot;(firstName: string, lastName?: string)=&gt;string&quot;. The default value of the default parameter disappears, leaving only the knowledge that the parameter is optional.
</p></div><h2 class="section-title"><a name="Rest Parameters" class="anchor" href="#Rest Parameters"><span class="header-link"></span></a>Rest Parameters</h2><div role="item"><p>必须参数，可选参数和默认参数有一个共同点：这些参数一次只描述一个参数。有时候你可能会想把多个参数设成一组，或是你没法确定一个函数最终会有多少个参数。在JavaScript中处理这些情况时，你可以直接使用函数体中可以获取的arguments来获得每一个参数。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Required, optional, and default parameters all have one thing in common: they&#39;re about talking about one parameter at a time. Sometimes, you want to work with multiple parameters as a group, or you may not know how many parameters a function will ultimately take. In JavaScript, you can work with the arguments direction using the arguments variable that is visible inside every function body.
</p></div><div role="item"><p>而在TypeScript中，你可以把这些参数聚集到一个变量中：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">In TypeScript, you can gather these arguments together into a variable:
</p></div><pre><code class="lang-js">function buildName(firstName: string, ...restOfName: string[]) {
  return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);
}

var employeeName = buildName(&quot;Joseph&quot;, &quot;Samuel&quot;, &quot;Lucas&quot;, &quot;MacKinzie&quot;);
</code></pre>
<div role="item"><p>剩余参数（rest parameters）可以包含多个可选参数。你可以按你的意愿随意使用这些参数。编译器会把传入函数的参数放入一个以省略号（...）开头为名字的变量之中，以供你在函数中使用。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Rest parameters are treated as a boundless number of optional parameters. You may leave them off, or have as many as you want. The compiler will build an array of the arguments you pass to the function under the name given after the ellipsis (...), allowing you to use it in your function. 
</p></div><div role="item"><p>省略号同时也可以用来定义带有剩余参数的函数上：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The ellipsis is also used in the type of the function with rest parameters:
</p></div><pre><code class="lang-js">function buildName(firstName: string, ...restOfName: string[]) {
  return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);
}

var buildNameFun: (fname: string, ...rest: string[])=&gt;string = buildName;
</code></pre>
<h2 class="section-title"><a name="Lambdas and using &#39;this&#39;" class="anchor" href="#Lambdas and using &#39;this&#39;"><span class="header-link"></span></a>Lambdas and using &#39;this&#39;</h2><div role="item"><p>学习&#39;this&#39;在函数中的工作方式几乎是每一个学习JavaScript的编码人员的必修课。实际上学习&#39;this&#39;的使用方式也是开发者习惯使用JavaScript的一个重要阶段。而TypeScript是JavaScript超集，它要求开发人员在懂得如何使用&#39;this&#39;的同时，也能够发现代码中没有被正确使用的&#39;this&#39;。关于JavaScript中的&#39;this&#39;已经完全足够用来写一篇文章了，并且实际上也有很多人这么干了。这里我们只关注一些基本的东西。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">How &#39;this&#39; works in JavaScript functions is a common theme in programmers coming to JavaScript. Indeed, learning how to use it is something of a rite of passage as developers become more accustomed to working in JavaScript. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use &#39;this&#39; and how to spot when it&#39;s not being used correctly. A whole article could be written on how to use &#39;this&#39; in JavaScript, and many have. Here, we&#39;ll focus on some of the basics. 
</p></div><div role="item"><p>JavaScript中的函数在被调用时会设置一个&#39;this&#39;变量。这个特性强大而又灵活，但使用这个特性却需要我们时刻关注函数执行的环境。举例来说，当我们在回调函数上执行一个函数时，这个函数的上下文环境就会变得难以预料。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">In JavaScript, &#39;this&#39; is a variable that&#39;s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This can be notoriously confusing, when, for example, when a function is used as a callback.
</p></div><div role="item"><p>让我们看一个例子：<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Let&#39;s look at an example:
</p></div><pre><code class="lang-js">var deck = {
    suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],
    cards: Array(52),
    createCardPicker: function() {
        return function() {
            var pickedCard = Math.floor(Math.random() * 52);
            var pickedSuit = Math.floor(pickedCard / 13);

            return {suit: this.suits[pickedSuit], card: pickedCard % 13};
        }
    }
}

var cardPicker = deck.createCardPicker();
var pickedCard = cardPicker();

alert(&quot;card: &quot; + pickedCard.card + &quot; of &quot; + pickedCard.suit);
</code></pre>
<div role="item"><p>虽然看起来这段代码会返回一个警告框，但实际上我们只会得到一个错误提示。因为&#39;createCardPicker&#39;创建的函数上的&#39;this&#39;指向的是&#39;window&#39;而不是&#39;deck&#39;对象。执行&#39;cardPicker()&#39;就会产生这样的结果。这里的&#39;this&#39;只能被动态绑定到&#39;window&#39;上（记住：在严格模式下，这里的&#39;this&#39;的值会是&#39;undefined&#39;而不是&#39;window&#39;）。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">If we tried to run the example, we would get an error instead of the expected alert box. This is because the &#39;this&#39; being used in the function created by &#39;createCardPicker&#39; will be set to &#39;window&#39; instead of our &#39;deck&#39; object. This happens as a result of calling &#39;cardPicker()&#39;. Here, there is no dynamic binding for &#39;this&#39; other than Window. (note: under strict mode, this will be undefined rather than window).
</p></div><div role="item"><p>要解决这一问题，我们就要保证这个函数在被调用之前是被绑定到了正确的&#39;this&#39;对象上。不管这个函数之后会被如何调用，只要我们正确地进行了绑定，这个函数就总能获得原始的&#39;deck&#39;对象。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">We can fix this by making sure the function is bound to the correct &#39;this&#39; before we return the function to be used later. This way, regardless of how its later used, it will still be able to see the original &#39;deck&#39; object.
</p></div><div role="item"><p>这里我们用拉姆达句法（lambda syntax，()=&gt;{}）来代替JavaScript的函数表达式以解决这个问题。它不是在函数被触发时再寻找&#39;this&#39;的对象，而是在函数被创建时就自动捕获&#39;this&#39;值代的对象。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">To fix this, we switching the function expression to use the lambda syntax ( ()=&gt;{} ) rather than the JavaScript function expression. This will automatically capture the &#39;this&#39; available when the function is created rather than when it is invoked:
</p></div><pre><code class="lang-js">var deck = {
    suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],
    cards: Array(52),
    createCardPicker: function() {
        // Notice: the line below is now a lambda, allowing us to capture &#39;this&#39; earlier
        return () =&gt; {
            var pickedCard = Math.floor(Math.random() * 52);
            var pickedSuit = Math.floor(pickedCard / 13);

            return {suit: this.suits[pickedSuit], card: pickedCard % 13};
        }
    }
}

var cardPicker = deck.createCardPicker();
var pickedCard = cardPicker();

alert(&quot;card: &quot; + pickedCard.card + &quot; of &quot; + pickedCard.suit);
</code></pre>
<div role="item"><p>你可以阅读Yahuda Katz的Understanding JavaScript Function Invocation and “this”来获取更多的信息。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">For more information on ways to think about &#39;this&#39;, you can read Yahuda Katz&#39;s Understanding JavaScript Function Invocation and “this”.
</p></div><h2 class="section-title"><a name="Overloads" class="anchor" href="#Overloads"><span class="header-link"></span></a>Overloads</h2><div role="item"><p>JavaScript本质上是一门动态性极强的语言。一个JavaScript函数根据传入参数的类型和数量来返回不同类型的对象。并且这样的使用方式并不少见。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">JavaScript is inherently a very dynamic language. It&#39;s not uncommon for a single JavaScript function to return different types of objects based on the shape of the arguments passed in. 
</p></div><pre><code class="lang-js">var suits = [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;];

function pickCard(x): any {
    // Check to see if we&#39;re working with an object/array
    // if so, they gave us the deck and we&#39;ll pick the card
    if (typeof x == &quot;object&quot;) {
        var pickedCard = Math.floor(Math.random() * x.length);
        return pickedCard;
    }
    // Otherwise just let them pick the card
    else if (typeof x == &quot;number&quot;) {
        var pickedSuit = Math.floor(x / 13);
        return { suit: suits[pickedSuit], card: x % 13 };
    }
}

var myDeck = [{ suit: &quot;diamonds&quot;, card: 2 }, { suit: &quot;spades&quot;, card: 10 }, { suit: &quot;hearts&quot;, card: 4 }];
var pickedCard1 = myDeck[pickCard(myDeck)];
alert(&quot;card: &quot; + pickedCard1.card + &quot; of &quot; + pickedCard1.suit);

var pickedCard2 = pickCard(15);
alert(&quot;card: &quot; + pickedCard2.card + &quot; of &quot; + pickedCard2.suit);
</code></pre>
<div role="item"><p>这里的&#39;pickCard&#39;函数会根据用户传入参数的不同来返回两种不同的结果。如果用户传入的是一个表示&#39;deck&#39;的对象，那这个函数就会返回&#39;pickedCard&#39;；如果用户要选择card（if the user picks the card），这个函数就会告诉用户card的结果。我们要如何用类型系统来描述这种情景呢？<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Here the &#39;pickCard&#39; function will return two different things based on what the user has passed in. If the users passes in an object that represents the deck, the function will pick the card. If the user picks the card, we tell them which card they&#39;ve picked. But how do we describe this to the type system.
</p></div><div role="item"><p>答案是用一个过载列表（a list of overloads）来描述函数的多个类型。编译器会用这个列表来处理函数调用。现在让我们用一个过载列表来描述&#39;pickCard&#39;所接收的参数和返回的类型。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">The answer is to supply multiple function types for the same function as a list of overloads. This list is what the compiler will use to resolve function calls. Let&#39;s create a list of overloads that describe what our &#39;pickCard&#39; accepts and what it returns.
</p></div><pre><code class="lang-js">var suits = [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;];

function pickCard(x: {suit: string; card: number; }[]): number;
function pickCard(x: number): {suit: string; card: number; };
function pickCard(x): any {
    // Check to see if we&#39;re working with an object/array
    // if so, they gave us the deck and we&#39;ll pick the card
    if (typeof x == &quot;object&quot;) {
        var pickedCard = Math.floor(Math.random() * x.length);
        return pickedCard;
    }
    // Otherwise just let them pick the card
    else if (typeof x == &quot;number&quot;) {
        var pickedSuit = Math.floor(x / 13);
        return { suit: suits[pickedSuit], card: x % 13 };
    }
}

var myDeck = [{ suit: &quot;diamonds&quot;, card: 2 }, { suit: &quot;spades&quot;, card: 10 }, { suit: &quot;hearts&quot;, card: 4 }];
var pickedCard1 = myDeck[pickCard(myDeck)];
alert(&quot;card: &quot; + pickedCard1.card + &quot; of &quot; + pickedCard1.suit);

var pickedCard2 = pickCard(15);
alert(&quot;card: &quot; + pickedCard2.card + &quot; of &quot; + pickedCard2.suit);
</code></pre>
<div role="item"><p>通过过载，我们现在就可以对&#39;pickCard&#39;函数进行类型检查了。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">With this change, the overloads now give us type-checked calls to the &#39;pickCard&#39; function. 
</p></div><div role="item"><p>编译器在进行类型检查时，其处理方式与普通的JavaScript相似。编译器会查看过载列表，并尝试与调用函数时的参数进行匹配。编译器会把第一个成功匹配的过载认做是正确的一个。正因为如此，我们需要把过载按照从最详细的到最粗略的顺序进行排序。<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">In order for the compiler to pick the correct typecheck, it follows a similar process to the underlying JavaScript. It looks at the overload list, and proceeding with the first overload attempts to call the function with the provided parameters. If it finds a match, it picks this overload as the correct overload. For this reason, its customary to order overloads from most specific to least specific.
</p></div><div role="item"><p>注意&#39;function pickCard(x): any&#39;并不会成为过载列表的一部分，即这个函数只有两个过载：其中一个以一个对象作为参数，另一个以一个数字作为参数。以任何其他的参数调用&#39;pickCard&#39;都会产生错误。#Generics
A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. Components that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems.<span class="check-ori" role="check-ori">[查看此处原文]</span></p><p role="ori" class="hide">Note that the &#39;function pickCard(x): any&#39; piece is not part of the overload list, so it only has two overloads: one that takes an object and one that takes a number. Calling &#39;pickCard&#39; with any other parameter types would cause an error.
</p></div><p>In languages like C# and Java, one of the main tools in the toolbox for creating reusable components is &#39;generics&#39;, that is, being able to create a component that can work over a variety of types rather than a single one. This allows users to consume these components and use their own types.</p>
<h2 class="section-title"><a name="Hello World of Generics" class="anchor" href="#Hello World of Generics"><span class="header-link"></span></a>Hello World of Generics</h2><p>To start off, let&#39;s do the &quot;hello world&quot; of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the &#39;echo&#39; command. </p>
<p>Without generics, we would either have to give the identity function a specific type:</p>
<pre><code class="lang-js">function identity(arg: number): number {
    return arg;
}
</code></pre>
<p>Or, we could describe the identity function using the &#39;any&#39; type:</p>
<pre><code class="lang-js">function identity(arg: any): any {
    return arg;
}
</code></pre>
<p>While using &#39;any&#39; is certainly generic in that will accept any and all types for the type of &#39;arg&#39;, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned. </p>
<p>Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a type variable, a special kind of variable that works on types rather than values. </p>
<pre><code class="lang-js">function identity&lt;T&gt;(arg: T): T {
    return arg;
}
</code></pre>
<p>We&#39;ve now added a type variable &#39;T&#39; to the identity function. This &#39;T&#39; allows us to capture the type the user provides (eg, number), so that we can use that information later. Here, we use &#39;T&#39; again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.</p>
<p>We say that this version of the &#39;identity&#39; function is generic, as it works over a range of types. Unlike using &#39;any&#39;, it&#39;s also just as precise (ie, it doesn&#39;t lose any information) as the first &#39;identity&#39; function that used numbers for the argument and return type.</p>
<p>Once we&#39;ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:</p>
<pre><code class="lang-js">var output = identity&lt;string&gt;(&quot;myString&quot;);  // type of output will be &#39;string&#39;
</code></pre>
<p>Here we explicitly set &#39;T&#39; to be string as one of the arguments to the function call, denoted using the &lt;&gt; around the arguments rather than ().</p>
<p>The second way is also perhaps the most common. Here we use /type argument inference/, that is, we want the compiler to set the value of T for us automatically based on the type of the argument we pass in:</p>
<pre><code class="lang-js">var output = identity(&quot;myString&quot;);  // type of output will be &#39;string&#39;
</code></pre>
<p>Notice that we didn&#39;t have explicitly pass the type in the angle brackets (&lt;&gt;), the compiler just looked at the value &quot;myString&quot;, and set T to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.</p>
<h2 class="section-title"><a name="Working with Generic Type Variables" class="anchor" href="#Working with Generic Type Variables"><span class="header-link"></span></a>Working with Generic Type Variables</h2><p>When you begin to use generics, you&#39;ll notice that when you create generic functions like &#39;identity&#39;, the compiler will enforce that you use any generically typed parameters in the body of the function correctly. That is, that you actually treat these parameters as if they could be any and all types.</p>
<p>Let&#39;s take our &#39;identity&#39; function from earlier:</p>
<pre><code class="lang-js">function identity&lt;T&gt;(arg: T): T {
    return arg;
}
</code></pre>
<p>What if want to also log the length of the argument &#39;arg&#39; to the console with each call. We might be tempted to write this:</p>
<pre><code class="lang-js">function loggingIdentity&lt;T&gt;(arg: T): T {
    console.log(arg.length);  // Error: T doesn&#39;t have .length
    return arg;
}
</code></pre>
<p>When we do, the compiler will give us an error that we&#39;re using the &quot;.length&quot; member of &#39;arg&#39;, but nowhere have we said that &#39;arg&#39; has this member. Remember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in a &#39;number&#39; instead, which does not have a &quot;.length&quot; member. </p>
<p>Let&#39;s say that we&#39;ve actually intended this function to work on arrays of T rather that T directly. Since we&#39;re working with arrays, the .length member should be available. We can describe this just like we would create arrays of other types:</p>
<pre><code class="lang-js">function loggingIdentity&lt;T&gt;(arg: T[]): T[] {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}
</code></pre>
<p>You can read the type of logging Identity as &quot;the generic function loggingIdentity, takes a type parameter T, and an argument &#39;arg&#39; which is an array of these T&#39;s, and returns an array of T&#39;s. If we passed in an array of numbers, we&#39;d get an array of numbers back out, as T would bind to number. This allows us to use our generic type variable &#39;T&#39; as part of the types we&#39;re working with, rather than the whole type, giving us greater flexibility. </p>
<p>We can alternatively write the sample example this way:</p>
<pre><code class="lang-js">function loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}
</code></pre>
<p>You may already be familiar with this style of type from other languages. In the next section, we&#39;ll cover how you can create your own generic types like Array<T>.</p>
<h2 class="section-title"><a name="Generic Types" class="anchor" href="#Generic Types"><span class="header-link"></span></a>Generic Types</h2><p>In previous sections, we created generic identity functions that worked over a range of types. In this section, we&#39;ll explore the type of the functions themselves and how to create generic interfaces.</p>
<p>The type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:</p>
<pre><code class="lang-js">function identity&lt;T&gt;(arg: T): T {
    return arg;
}

var myIdentity: &lt;T&gt;(arg: T)=&gt;T = identity;
</code></pre>
<p>We could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up.</p>
<pre><code class="lang-js">function identity&lt;T&gt;(arg: T): T {
    return arg;
}

var myIdentity: &lt;U&gt;(arg: U)=&gt;U = identity;
</code></pre>
<p>We can also write the generic type as a call signature of an object literal type:</p>
<pre><code class="lang-js">function identity&lt;T&gt;(arg: T): T {
    return arg;
}

var myIdentity: {&lt;T&gt;(arg: T): T} = identity;
</code></pre>
<p>Which leads us to writing our first generic interface. Let&#39;s take the object literal from the previous example and move it to an interface:</p>
<pre><code class="lang-js">interface GenericIdentityFn {
    &lt;T&gt;(arg: T): T;
}

function identity&lt;T&gt;(arg: T): T {
    return arg;
}

var myIdentity: GenericIdentityFn = identity;
</code></pre>
<p>In a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) we&#39;re generic over (eg Dictionary<string> rather than just Dictionary). This makes the type parameter visible to all the other members of the interface. </p>
<pre><code class="lang-js">interface GenericIdentityFn&lt;T&gt; {
    (arg: T): T;
}

function identity&lt;T&gt;(arg: T): T {
    return arg;
}

var myIdentity: GenericIdentityFn&lt;number&gt; = identity;
</code></pre>
<p>Notice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use GenericIdentityFn, we now will also need to specify the corresponding type argument (here: number), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.</p>
<p>In addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and modules.</p>
<h2 class="section-title"><a name="Generic Classes" class="anchor" href="#Generic Classes"><span class="header-link"></span></a>Generic Classes</h2><p>A generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets (&lt;&gt;) following the name of the class.</p>
<pre><code class="lang-js">class GenericNumber&lt;T&gt; {
    zeroValue: T;
    add: (x: T, y: T) =&gt; T;
}

var myGenericNumber = new GenericNumber&lt;number&gt;();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };
</code></pre>
<p>This is a pretty literal use of the &#39;GenericNumber&#39; class, but you may have noticed that nothing is restricting is to only use the &#39;number&#39; type. We could have instead used &#39;string&#39; or even more complex objects.</p>
<pre><code class="lang-js">var stringNumeric = new GenericNumber&lt;string&gt;();
stringNumeric.zeroValue = &quot;&quot;;
stringNumeric.add = function(x, y) { return x + y; };

alert(stringNumeric.add(stringNumeric.zeroValue, &quot;test&quot;));
</code></pre>
<p>Just as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type.</p>
<p>As we covered in Classes, a class has two side to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class&#39;s type parameter.</p>
<h2 class="section-title"><a name="Generic Constraints" class="anchor" href="#Generic Constraints"><span class="header-link"></span></a>Generic Constraints</h2><p>If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have. In our &#39;loggingIdentity&#39; example, we wanted to be able access the &quot;.length&quot; property of &#39;arg&#39;, but the compiler could not prove that every type had a &quot;.length&quot; property, so it warns us that we can&#39;t make this assumption.</p>
<pre><code class="lang-js">function loggingIdentity&lt;T&gt;(arg: T): T {
    console.log(arg.length);  // Error: T doesn&#39;t have .length
    return arg;
}
</code></pre>
<p>Instead of working with any and all types, we&#39;d like to constrain this function to work with any and all types that also have the &quot;.length&quot; property. As long as the type has this member, we&#39;ll allow it, but it&#39;s required to have at least this member. To do so, we must list our requirement as a constraint on what T can be.</p>
<p>To do so, we&#39;ll create an interface that describes our constraint. Here, we&#39;ll create an interface that has a single &quot;.length&quot; property and then we&#39;ll use this interface and the extends keyword to denote our constraint:</p>
<pre><code class="lang-js">interface Lengthwise {
    length: number;
}

function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {
    console.log(arg.length);  // Now we know it has a .length property, so no more error
    return arg;
}
</code></pre>
<p>Because the generic function is now constrained, it will no longer work over any and all types:</p>
<pre><code class="lang-js">loggingIdentity(3);  // Error, number doesn&#39;t have a .length property
</code></pre>
<p>Instead, we need to pass in values whose type has all the required properties:</p>
<pre><code class="lang-js">loggingIdentity({length: 10, value: 3});
</code></pre>
<h2 class="section-title"><a name="Using Type Parameters in Generic Constraints" class="anchor" href="#Using Type Parameters in Generic Constraints"><span class="header-link"></span></a>Using Type Parameters in Generic Constraints</h2><p>In some cases, it may be useful to declare a type parameter that is constrained by another type parameter. For example,</p>
<pre><code class="lang-js">function find&lt;T, U extends Findable&lt;T&gt;&gt;(n: T, s: U) {   // errors because type parameter used in constraint
  // ...
} 
find (giraffe, myAnimals);
</code></pre>
<p>You can achieve the pattern above by replacing the type parameter with its constraint. Rewriting the example above,</p>
<pre><code class="lang-js">function find&lt;T&gt;(n: T, s: Findable&lt;T&gt;) {   
  // ...
} 
find(giraffe, myAnimals);
</code></pre>
<p>Note: The above is not strictly identical, as the return type of the first function could have returned &#39;U&#39;, which the second function pattern does not provide a means to do.</p>
<h2 class="section-title"><a name="Using Class Types in Generics" class="anchor" href="#Using Class Types in Generics"><span class="header-link"></span></a>Using Class Types in Generics</h2><p>When creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,</p>
<pre><code class="lang-js">function create&lt;T&gt;(c: {new(): T; }): T { 
    return new c();
}
</code></pre>
<p>A more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types.</p>
<pre><code class="lang-js">class BeeKeeper {
    hasMask: boolean;
}

class ZooKeeper {
    nametag: string; 
}

class Animal {
    numLegs: number;
}

class Bee extends Animal {
    keeper: BeeKeeper;
}

class Lion extends Animal {
    keeper: ZooKeeper;
}

function findKeeper&lt;A extends Animal, K&gt; (a: {new(): A; 
    prototype: {keeper: K}}): K {

    return a.prototype.keeper;
}

findKeeper(Lion).nametag;  // typechecks!
</code></pre>
<h1 class="section-title"><a name="Common Errors" class="anchor" href="#Common Errors"><span class="header-link"></span></a>Common Errors</h1><p>The list below captures some of the commonly confusing error messages that you may encounter when using the TypeScript language and Compiler</p>
<h2 class="section-title"><a name="Commonly Confusing Errors" class="anchor" href="#Commonly Confusing Errors"><span class="header-link"></span></a>Commonly Confusing Errors</h2><h3 class="section-title"><a name="&quot;tsc.exe&quot; exited with error code 1." class="anchor" href="#&quot;tsc.exe&quot; exited with error code 1."><span class="header-link"></span></a>&quot;tsc.exe&quot; exited with error code 1.</h3><p><strong>Fixes:</strong>
check file-encoding is UTF-8 - <a href="https://typescript.codeplex.com/workitem/1587">https://typescript.codeplex.com/workitem/1587</a></p>
<h3 class="section-title"><a name="external module XYZ cannot be resolved" class="anchor" href="#external module XYZ cannot be resolved"><span class="header-link"></span></a>external module XYZ cannot be resolved</h3><p><strong>Fixes:</strong>
check if module path is case-sensitive - <a href="https://typescript.codeplex.com/workitem/2134">https://typescript.codeplex.com/workitem/2134</a></p>
<h1 class="section-title"><a name="Mixins" class="anchor" href="#Mixins"><span class="header-link"></span></a>Mixins</h1><p>Along with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes. You may be familiar with the idea of mixins or traits for languages like Scala, and the pattern has also reached some popularity in the JavaScript community.</p>
<h2 class="section-title"><a name="Mixin sample" class="anchor" href="#Mixin sample"><span class="header-link"></span></a>Mixin sample</h2><p>In the code below, we show how you can model mixins in TypeScript. After the code, we&#39;ll break down how it works.</p>
<pre><code class="lang-js">// Disposable Mixin
class Disposable {
    isDisposed: boolean;
    dispose() {
        this.isDisposed = true;
    }

}

// Activatable Mixin
class Activatable {
    isActive: boolean;
    activate() {
        this.isActive = true;
    }
    deactivate() {
        this.isActive = false;
    }
}

class SmartObject implements Disposable, Activatable {
    constructor() {
        setInterval(() =&gt; console.log(this.isActive + &quot; : &quot; + this.isDisposed), 500);
    }

    interact() {
        this.activate();
    }

    // Disposable
    isDisposed: boolean = false;
    dispose: () =&gt; void;
    // Activatable
    isActive: boolean = false;
    activate: () =&gt; void;
    deactivate: () =&gt; void;
}
applyMixins(SmartObject, [Disposable, Activatable])

var smartObj = new SmartObject();
setTimeout(() =&gt; smartObj.interact(), 1000);

////////////////////////////////////////
// In your runtime library somewhere
////////////////////////////////////////

function applyMixins(derivedCtor: any, baseCtors: any[]) {
    baseCtors.forEach(baseCtor =&gt; {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; {
            derivedCtor.prototype[name] = baseCtor.prototype[name];
        })
    }); 
}
</code></pre>
<h2 class="section-title"><a name="Understanding the sample" class="anchor" href="#Understanding the sample"><span class="header-link"></span></a>Understanding the sample</h2><p>The code sample starts with the two classes that will act is our mixins. You can see each one is focused on a particular activity or capability. We&#39;ll later mix these together to form a new class from both capabilities.</p>
<pre><code class="lang-js">// Disposable Mixin
class Disposable {
    isDisposed: boolean;
    dispose() {
        this.isDisposed = true;
    }

}

// Activatable Mixin
class Activatable {
    isActive: boolean;
    activate() {
        this.isActive = true;
    }
    deactivate() {
        this.isActive = false;
    }
}
</code></pre>
<p>Next, we&#39;ll create the class that will handle the combination of the two mixins. Let&#39;s look at this in more detail to see how it does this:</p>
<pre><code class="lang-js">class SmartObject implements Disposable, Activatable {
</code></pre>
<p>The first thing you may notice in the above is that instead of using &#39;extends&#39;, we use &#39;implements&#39;. This treats the classes as interfaces, and only uses the types behind Disposable and Activatable rather than the implementation. This means that we&#39;ll have to provide the implementation in class. Except, that&#39;s exactly what we want to avoid by using mixins. </p>
<p>To satisfy this requirement, we create stand-in properties and their types for the members that will come from our mixins. This satisfies the compiler that these members will be available at runtime. This lets us still get the benefit of the mixins, albeit with a some bookkeeping overhead.</p>
<pre><code class="lang-js">// Disposable
isDisposed: boolean = false;
dispose: () =&gt; void;
// Activatable
isActive: boolean = false;
activate: () =&gt; void;
deactivate: () =&gt; void;
</code></pre>
<p>Finally, we mix our mixins into the class, creating the full implementation.</p>
<pre><code class="lang-js">applyMixins(SmartObject, [Disposable, Activatable])
</code></pre>
<p>Lastly, we create a helper function that will do the mixing for us. This will run through the properties of each of the mixins and copy them over to the target of the mixins, filling out the stand-in properties with their implementations.</p>
<pre><code class="lang-js">function applyMixins(derivedCtor: any, baseCtors: any[]) {
    baseCtors.forEach(baseCtor =&gt; {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; {
            derivedCtor.prototype[name] = baseCtor.prototype[name];
        })
    }); 
}
</code></pre>
<h1 class="section-title"><a name="Declaration Merging" class="anchor" href="#Declaration Merging"><span class="header-link"></span></a>Declaration Merging</h1><p>Some of the unique concepts in TypeScript come from the need to describe what is happening to the shape of JavaScript objects at the type level. One example that is especially unique to TypeScript is the concept of &#39;declaration merging&#39;. Understanding this concept will give you an advantage when working with existing JavaScript in your TypeScript. It also opens the door to more advanced abstraction concepts.</p>
<p>First, before we get into how declarations merge, let&#39;s first describe what we mean by &#39;declaration merging&#39;.</p>
<p>For the purposes of this article, declaration merging specifically means that the compiler is doing the work of merging two separate declarations declared with the same name into a single definition. This merged definition has the features of both of the original declarations. Declaration merging is not limited to just two declarations, as any number of declarations can be merged. </p>
<h2 class="section-title"><a name="Basic Concepts" class="anchor" href="#Basic Concepts"><span class="header-link"></span></a>Basic Concepts</h2><p>In TypeScript, a declaration exists in one of three groups: namespace/module, type, or value. Declarations that create a namespace/module are accessed using a dotted notation when writing a type. Declarations that create a type do just that, create a type that is visible with the declared shape and bound to the given name. Lastly, declarations create a value are those that are visible in the output JavaScript (eg, functions and variables).</p>
<p>Declaration Type  Namespace Type  Value
Module  X   X
Class   X X
Interface   X 
Function      X
Variable      X</p>
<p>Understanding what is created with each declaration will help you understand what is merged when you perform a declaration merge.</p>
<h2 class="section-title"><a name="Merging Interfaces" class="anchor" href="#Merging Interfaces"><span class="header-link"></span></a>Merging Interfaces</h2><p>The simplest, and perhaps most common, type of declaration merging is interface merging. At the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name.</p>
<pre><code class="lang-js">interface Box {
    height: number;
    width: number;
}

interface Box {
    scale: number;
}

var box: Box = {height: 5, width: 6, scale: 10};
</code></pre>
<p>Non-function members of the interfaces must be unique. The compiler will issue an error if the interfaces both declare a non-function member of the same name.</p>
<p>For function members, each function member of the same name is treated as describing an overload of the same function. Of note, too, is that in the case of interface A merging with later interface A (here called A&#39;), the overload set of A&#39; will have a higher precedence than that of interface A. </p>
<p>That is, in the example:</p>
<pre><code class="lang-js">interface Document {
    createElement(tagName: any): Element;
}
interface Document {
    createElement(tagName: string): HTMLElement;
}
interface Document {
    createElement(tagName: &quot;div&quot;): HTMLDivElement; 
    createElement(tagName: &quot;span&quot;): HTMLSpanElement;
    createElement(tagName: &quot;canvas&quot;): HTMLCanvasElement;
}
</code></pre>
<p>The two interfaces will merge to create a single declaration. Notice that the elements of each group maintains the same order, just the groups themselves are merged with later overload sets coming first:</p>
<pre><code class="lang-js">interface Document {
    createElement(tagName: &quot;div&quot;): HTMLDivElement; 
    createElement(tagName: &quot;span&quot;): HTMLSpanElement;
    createElement(tagName: &quot;canvas&quot;): HTMLCanvasElement;
    createElement(tagName: string): HTMLElement;
    createElement(tagName: any): Element;
}
</code></pre>
<h2 class="section-title"><a name="Merging Modules" class="anchor" href="#Merging Modules"><span class="header-link"></span></a>Merging Modules</h2><p>Similarly to interfaces, modules of the same name will also merge their members. Since modules create both a namespace and a value, we need to understand how both merge.</p>
<p>To merge the namespaces, type definitions from exported interfaces declared in each module are themselves merged, forming a single namespace with merged interface definitions inside.</p>
<p>To merge the value, at each declaration site, if a module already exists with the given name, it is further extended by taking the existing module and adding the exported members of the second module to the first. </p>
<p>The declaration merge of &#39;Animals&#39; in this example:</p>
<pre><code class="lang-js">module Animals {
    export class Zebra { }
}

module Animals {
    export interface Legged { numberOfLegs: number; }
    export class Dog { }
}
</code></pre>
<p>is equivalent to:</p>
<pre><code class="lang-js">module Animals {
    export interface Legged { numberOfLegs: number; }

    export class Zebra { }
    export class Dog { }
}
</code></pre>
<p>This model of module merging is a helpful starting place, but to get a more complete picture we need to also understand what happens with non-exported members. Non-exported members are only visible in the original (un-merged) module. This means that after merging, merged members that came from other declarations can not see non-exported members.</p>
<p>We can see this more clearly in this example:</p>
<pre><code class="lang-js">module Animal {
    var haveMuscles = true;

    export function animalsHaveMuscles() {
        return haveMuscles;
    }
}

module Animal {
    export function doAnimalsHaveMuscles() {
        return haveMuscles;  // &lt;-- error, haveMuscles is not visible here
    }
}
</code></pre>
<p>Because haveMuscles is not exported, only the animalsHaveMuscles function that shares the same un-merged module can see the symbol. The doAnimalsHaveMuscles function, even though it&#39;s part of the merged Animal module can not see this un-exported member.</p>
<h2 class="section-title"><a name="Merging Modules with Classes, Functions, and Enums" class="anchor" href="#Merging Modules with Classes, Functions, and Enums"><span class="header-link"></span></a>Merging Modules with Classes, Functions, and Enums</h2><p>Modules are flexible enough to also merge with other types of declarations. To do so, the module declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types. TypeScript uses this capability to model some of patterns in JavaScript as well as other programming languages.</p>
<p>The first module merge we&#39;ll cover is merging a module with a class. This gives the user a way of describing inner classes.</p>
<pre><code class="lang-js">class Album {
    label: Album.AlbumLabel;
}
module Album {
    export class AlbumLabel { }
}
</code></pre>
<p>The visibility rules for merged members is the same as described in the &#39;Merging Modules&#39; section, so we must export the AlbumLabel class for the merged class to see it. The end result is a class managed inside of another class. You can also use modules to add more static members to an existing class.</p>
<p>In addition to the pattern of inner classes, you may also be familiar with JavaScript practice of creating a function and then extending the function further by adding properties onto the function. TypeScript uses declaration merging to build up definitions like this in a type-safe way. </p>
<pre><code class="lang-js">function buildLabel(name: string): string {
    return buildLabel.prefix + name + buildLabel.suffix;
}

module buildLabel {
    export var suffix = &quot;&quot;;
    export var prefix = &quot;Hello, &quot;;
}

alert(buildLabel(&quot;Sam Smith&quot;));
</code></pre>
<p>Similarly, modules can be used to extend enums with static members:</p>
<pre><code class="lang-js">enum Color {
    red = 1,
    green = 2,
    blue = 4
}

module Color {
    export function mixColor(colorName: string) {
        if (colorName == &quot;yellow&quot;) {
            return Color.red + Color.green;
        }
        else if (colorName == &quot;white&quot;) {
            return Color.red + Color.green + Color.blue;
        }
        else if (colorName == &quot;magenta&quot;) {
            return Color.red + Color.blue;
        }
        else if (colorName == &quot;cyan&quot;) {
            return Color.green + Color.blue;
        }
    }
}
</code></pre>
<h2 class="section-title"><a name="Disallowed Merges" class="anchor" href="#Disallowed Merges"><span class="header-link"></span></a>Disallowed Merges</h2><p>Not all merges are allowed in TypeScript. Currently, classes can not merge with other classes, variables and classes can not merge, nor can interfaces and classes. For information on mimicking classes merging, see the Mixins in TypeScript section.</p>
<h1 class="section-title"><a name="Type Inference" class="anchor" href="#Type Inference"><span class="header-link"></span></a>Type Inference</h1><p>In this section, we will cover type inference in TypeScript. Namely, we&#39;ll discuss where and how types are inferred.</p>
<h2 class="section-title"><a name="Basics" class="anchor" href="#Basics"><span class="header-link"></span></a>Basics</h2><p>In TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation. For example, in this code</p>
<pre><code class="lang-js">var x = 3;
</code></pre>
<p>The type of the x variable is inferred to be number. This kind of inference takes place when initializing variables and members, setting parameter default values, and determining function return types.</p>
<p>In most cases, type inference is straightforward. In the following sections, we&#39;ll explore some of the nuance in how types are inferred.</p>
<h2 class="section-title"><a name="Best common type" class="anchor" href="#Best common type"><span class="header-link"></span></a>Best common type</h2><p>When a type inference is made from several expressions, the types of those expressions are used to calculate a &quot;best common type&quot;. For example,</p>
<pre><code class="lang-js">var x = [0, 1, null];
</code></pre>
<p>To infer the type of x in the example above, we must consider the type of each array element. Here we are given two choices for the type of the array: number and null. The best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates. </p>
<p>Because the best common type has to be chosen from the provided candidate types, there are some cases where types share a common structure, but no one type is the super type of all candidate types. For example:</p>
<pre><code class="lang-js">var zoo = [new Rhino(), new Elephant(), new Snake()];
</code></pre>
<p>Ideally, we may want zoo to be inferred as an Animal[], but because there is no object that is strictly of type Animal in the array, we make no inference about the array element type. To correct this, instead explicitly provide the type when no one type is a super type of all other candidates:</p>
<pre><code class="lang-js">var zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];
</code></pre>
<p>When no best common type is found, the resulting inference is the empty object type, {}. Because this type has no members, attempting to use any properties of it will cause an error. This result allows you to still use the object in a type-agnostic manner, while providing type safety in cases where the type of the object can&#39;t be implicitly determined.</p>
<h2 class="section-title"><a name="Contextual Type" class="anchor" href="#Contextual Type"><span class="header-link"></span></a>Contextual Type</h2><p>Type inference also works in &quot;the other direction&quot; in some cases in TypeScript. This is known as &quot;contextual typing&quot;. Contextual typing occurs when the type of an expression is implied by its location. For example: </p>
<pre><code class="lang-js">window.onmousedown = function(mouseEvent) { 
    console.log(mouseEvent.buton);  //&lt;- Error  
};
</code></pre>
<p>For the code above to give the type error, the TypeScript type checker used the type of the Window.onmousedown function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the type of the mouseEvent parameter. If this function expression were not in a contextually typed position, the mouseEvent parameter would have type any, and no error would have been issued.</p>
<p>If the contextually typed expression contains explicit type information, the contextual type is ignored. Had we written the above example:</p>
<pre><code class="lang-js">window.onmousedown = function(mouseEvent: any) { 
    console.log(mouseEvent.buton);  //&lt;- Now, no error is given  
};
</code></pre>
<p>The function expression with an explicit type annotation on the parameter will override the contextual type. Once it does so, no error is given as no contextual type applies.</p>
<p>Contextual typing applies in many cases. Common cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements. The contextual type also acts as a candidate type in best common type. For example:</p>
<pre><code class="lang-js">function createZoo(): Animal[] {
    return [new Rhino(), new Elephant(), new Snake()];
}
</code></pre>
<p>In this example, best common type has a set of four candidates: Animal, Rhino, Elephant, and Snake. Of these, Animal can be chosen by the best common type algorithm.</p>
<h1 class="section-title"><a name="Type Compatibility" class="anchor" href="#Type Compatibility"><span class="header-link"></span></a>Type Compatibility</h1><p>Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with nominal typing. Consider the following code:</p>
<pre><code class="lang-js">interface Named {
    name: string;
}

class Person {
    name: string;
}

var p: Named;
// OK, because of structural typing
p = new Person();
</code></pre>
<p>In nominally-typed languages like C# or Java, the equivalent code would be an error because the Person class does not explicitly describe itself as being an implementor of the Named interface.</p>
<p>TypeScript’s structural type system was designed based on how JavaScript code is typically written. Because JavaScript widely uses anonymous objects like function expressions and object literals, it’s much more natural to represent the kinds of relationships found in JavaScript libraries with a structural type system instead of a nominal one.</p>
<h2 class="section-title"><a name="A Note on Soundness" class="anchor" href="#A Note on Soundness"><span class="header-link"></span></a>A Note on Soundness</h2><p>TypeScript’s type system allows certain operations that can’t be known at compile-time to be safe. When a type system has this property, it is said to not be “sound”. The places where TypeScript allows unsound behavior were carefully considered, and throughout this document we’ll explain where these happen and the motivating scenarios behind them.</p>
<h2 class="section-title"><a name="Starting out" class="anchor" href="#Starting out"><span class="header-link"></span></a>Starting out</h2><p>The basic rule for TypeScript’s structural type system is that x is compatible with y if y has at least the same members as x. For example:</p>
<pre><code class="lang-js">interface Named {
    name: string;
}

var x: Named;
// y’s inferred type is { name: string; location: string; }
var y = { name: &#39;Alice&#39;, location: &#39;Seattle&#39; };
x = y;
</code></pre>
<p>To check whether y can be assigned to x, the compiler checks each property of x to find a corresponding compatible property in y. In this case, y must have a member called ‘name’ that is a string. It does, so the assignment is allowed.</p>
<p>The same rule for assignment is used when checking function call arguments:</p>
<pre><code class="lang-js">function greet(n: Named) {
    alert(&#39;Hello, &#39; + n.name);
}
greet(y); // OK
</code></pre>
<p>Note that ‘y’ has an extra ‘location’ property, but this does not create an error. Only members of the target type (‘Named’ in this case) are considered when checking for compatibility.</p>
<p>This comparison process proceeds recursively, exploring the type of each member and sub-member.</p>
<h2 class="section-title"><a name="Comparing two functions" class="anchor" href="#Comparing two functions"><span class="header-link"></span></a>Comparing two functions</h2><p>While comparing primitive types and object types is relatively straightforward, the question of what kinds of functions should be considered compatible. Let’s start with a basic example of two functions that differ only in their argument lists:</p>
<pre><code class="lang-js">var x = (a: number) =&gt; 0;
var y = (b: number, s: string) =&gt; 0;

y = x; // OK
x = y; // Error
</code></pre>
<p>To check if x is assignable to y, we first look at the parameter list. Each parameter in y must have a corresponding parameter in x with a compatible type. Note that the names of the parameters are not considered, only their types. In this case, every parameter of x has a corresponding compatible parameter in y, so the assignment is allowed.</p>
<p>The second assignment is an error, because y has a required second parameter that ‘x’ does not have, so the assignment is disallowed.</p>
<p>You may be wondering why we allow ‘discarding’ parameters like in the example y = x. The reason is that assignment is allowed is that ignoring extra function parameters is actually quite common in JavaScript. For example, Array#forEach provides three arguments to the callback function: the array element, its index, and the containing array. Nevertheless, it’s very useful to provide a callback that only uses the first argument:</p>
<pre><code class="lang-js">var items = [1, 2, 3];

// Don&#39;t force these extra arguments
items.forEach((item, index, array) =&gt; console.log(item));

// Should be OK!
items.forEach((item) =&gt; console.log(item));
</code></pre>
<p>Now let’s look at how return types are treated, using two functions that differ only by their return type:</p>
<pre><code class="lang-js">var x = () =&gt; ({name: &#39;Alice&#39;});
var y = () =&gt; ({name: &#39;Alice&#39;, location: &#39;Seattle&#39;});

x = y; // OK
y = x; // Error because x() lacks a location property
</code></pre>
<p>The type system enforces that the source function’s return type be a subtype of the target type’s return type.</p>
<h3 class="section-title"><a name="Function Argument Bivariance" class="anchor" href="#Function Argument Bivariance"><span class="header-link"></span></a>Function Argument Bivariance</h3><p>When comparing the types of function parameters, assignment succeeds if either the source parameter is assignable to the target parameter, or vice versa. This is unsound because a caller might end up being given a function that takes a more specialized type, but invokes the function with a less specialized type. In practice, this sort of error is rare, and allowing this enables many common JavaScript patterns. A brief example:</p>
<pre><code class="lang-js">enum EventType { Mouse, Keyboard }

interface Event { timestamp: number; }
interface MouseEvent extends Event { x: number; y: number }
interface KeyEvent extends Event { keyCode: number }

function listenEvent(eventType: EventType, handler: (n: Event) =&gt; void) {
    /* ... */
}

// Unsound, but useful and common
listenEvent(EventType.Mouse, (e: MouseEvent) =&gt; console.log(e.x + &#39;,&#39; + e.y));

// Undesirable alternatives in presence of soundness
listenEvent(EventType.Mouse, (e: Event) =&gt; console.log((&lt;MouseEvent&gt;e).x + &#39;,&#39; + (&lt;MouseEvent&gt;e).y));
listenEvent(EventType.Mouse, &lt;(e: Event) =&gt; void&gt;((e: MouseEvent) =&gt; console.log(e.x + &#39;,&#39; + e.y)));

// Still disallowed (clear error). Type safety enforced for wholly incompatible types
listenEvent(EventType.Mouse, (e: number) =&gt; console.log(e));
</code></pre>
<h3 class="section-title"><a name="Optional Arguments and Rest Arguments" class="anchor" href="#Optional Arguments and Rest Arguments"><span class="header-link"></span></a>Optional Arguments and Rest Arguments</h3><p>When comparing functions for compatibility, optional and required parameters are interchangeable. Extra optional parameters of the source type are not an error, and optional parameters of the target type without corresponding parameters in the target type are not an error.</p>
<p>When a function has a rest parameter, it is treated as if it were an infinite series of optional parameters.</p>
<p>This is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing ‘undefined’ in that position is equivalent for most functions.</p>
<p>The motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:</p>
<pre><code class="lang-js">function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) {
    /* ... Invoke callback with &#39;args&#39; ... */
}

// Unsound - invokeLater &quot;might&quot; provide any number of arguments
invokeLater([1, 2], (x, y) =&gt; console.log(x + &#39;, &#39; + y));

// Confusing (x and y are actually required) and undiscoverable
invokeLater([1, 2], (x?, y?) =&gt; console.log(x + &#39;, &#39; + y));
</code></pre>
<h3 class="section-title"><a name="Functions with overloads" class="anchor" href="#Functions with overloads"><span class="header-link"></span></a>Functions with overloads</h3><p>When a function has overloads, each overload in the source type must be matched by a compatible signature on the target type. This ensures that the target function can be called in all the same situations as the source function. Functions with specialized overload signatures (those that use string literals in their overloads) do not use their specialized signatures when checking for compatibility.</p>
<h2 class="section-title"><a name="Enums" class="anchor" href="#Enums"><span class="header-link"></span></a>Enums</h2><p>Enums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,</p>
<pre><code class="lang-js">enum Status { Ready, Waiting };
enum Color { Red, Blue, Green };

var status = Status.Ready;
status = Color.Green;  //error
</code></pre>
<h2 class="section-title"><a name="Classes" class="anchor" href="#Classes"><span class="header-link"></span></a>Classes</h2><p>Classes work similarly to object literal types and interfaces with one exception: they have both a static and an instance type. When comparing two objects of a class type, only members of the instance are compared. Static members and constructors do not affect compatibility. </p>
<pre><code class="lang-js">class Animal {
    feet: number;
    constructor(name: string, numFeet: number) { }
}

class Size {
    feet: number;
    constructor(numFeet: number) { }
}

var a: Animal;
var s: Size;

a = s;  //OK
s = a;  //OK
</code></pre>
<h3 class="section-title"><a name="Private members in classes" class="anchor" href="#Private members in classes"><span class="header-link"></span></a>Private members in classes</h3><p>Private members in a class affect their compatibility. When an instance of a class is checked for compatibility, if it contains a private member, the target type must also contain a private member that originated from the same class. This allows, for example, a class to be assignment compatible with its super class but not with classes from a different inheritance hierarchy which otherwise have the same shape.</p>
<h2 class="section-title"><a name="Generics" class="anchor" href="#Generics"><span class="header-link"></span></a>Generics</h2><p>Because TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,</p>
<pre><code class="lang-js">interface Empty&lt;T&gt; {
}
var x: Empty&lt;number&gt;;
var y: Empty&lt;string&gt;;

x = y;  // okay, y matches structure of x
</code></pre>
<p>In the above, x and y are compatible because their structures do not use the type argument in a differentiating way. Changing this example by adding a member to Empty<T> shows how this works:</p>
<pre><code class="lang-js">interface NotEmpty&lt;T&gt; {
    data: T;
}
var x: NotEmpty&lt;number&gt;;
var y: NotEmpty&lt;string&gt;;

x = y;  // error, x and y are not compatible
</code></pre>
<p>In this way, a generic type that has its type arguments specified acts just like a non-generic type.</p>
<p>For generic types that do not have their type arguments specified, compatibility is checked by specifying &#39;any&#39; in place of all unspecified type arguments. The resulting types are then checked for compatibility, just as in the non-generic case.</p>
<p>For example,</p>
<pre><code class="lang-js">var identity = function&lt;T&gt;(x: T): T { 
    // ...
}

var reverse = function&lt;U&gt;(y: U): U {
    // ...
}

identity = reverse;  // Okay because (x: any)=&gt;any matches (y: any)=&gt;any
</code></pre>
<h2 class="section-title"><a name="Advanced Topics" class="anchor" href="#Advanced Topics"><span class="header-link"></span></a>Advanced Topics</h2><h3 class="section-title"><a name="Subtype vs Assignment" class="anchor" href="#Subtype vs Assignment"><span class="header-link"></span></a>Subtype vs Assignment</h3><p>So far, we&#39;ve used &#39;compatible&#39;, which is not a term defined in the language spec. In TypeScript, there are two kinds of compatibility: subtype and assignment. These differ only in that assignment extends subtype compatibility with rules to allow assignment to and from &#39;any&#39; and to and from enum with corresponding numeric values. </p>
<p>Different places in the language use one of the two compatibility mechanisms, depending on the situation. For practical purposes, type compatibility is dictated by assignment compatibility even in the cases of the implements and extends clauses. For more information, see the TypeScript spec.</p>
<h1 class="section-title"><a name="Writing .d.ts files" class="anchor" href="#Writing .d.ts files"><span class="header-link"></span></a>Writing .d.ts files</h1><p>When using an external JavaScript library, or new host API, you&#39;ll need to use a declaration file (.d.ts) to describe the shape of that library. This guide covers a few high-level concepts specific to writing definition files, then proceeds with a number of examples that show how to transcribe various concepts to their matching definition file descriptions.</p>
<h2 class="section-title"><a name="Guidelines and Specifics" class="anchor" href="#Guidelines and Specifics"><span class="header-link"></span></a>Guidelines and Specifics</h2><h3 class="section-title"><a name="Workflow" class="anchor" href="#Workflow"><span class="header-link"></span></a>Workflow</h3><p>The best way to write a .d.ts file is to start from the documentation of the library, not the code. Working from the documentation ensures the surface you present isn&#39;t muddied with implementation details, and is typically much easier to read than JS code. The examples below will be written as if you were reading documentation that presented example calling code.</p>
<h3 class="section-title"><a name="Namespacing" class="anchor" href="#Namespacing"><span class="header-link"></span></a>Namespacing</h3><p>When defining interfaces (for example, &quot;options&quot; objects), you have a choice about whether to put these types inside a module or not. This is largely a judgement call -- if the consumer is likely to often declare variables or parameters of that type, and the type can be named without risk of colliding with other types, prefer placing it in the global namespace. If the type is not likely to be referenced directly, or can&#39;t be named with a reasonably unique name, do use a module to prevent it from colliding with other types.</p>
<h3 class="section-title"><a name="Callbacks" class="anchor" href="#Callbacks"><span class="header-link"></span></a>Callbacks</h3><p>Many JavaScript libraries take a function as a parameter, then invoke that function later with a known set of arguments. When writing the function signatures for these types, do not mark those parameters as optional. The right way to think of this is &quot;What parameters will be provided?&quot;, not &quot;What parameters will be consumed?&quot;. While TypeScript 0.9.7 and above does not enforce that the optionality, bivariance on argument optionality might be enforced by an external linter.</p>
<h3 class="section-title"><a name="Extensibility and Declaration Merging" class="anchor" href="#Extensibility and Declaration Merging"><span class="header-link"></span></a>Extensibility and Declaration Merging</h3><p>When writing definition files, it&#39;s important to remember TypeScript&#39;s rules for extending existing objects. You might have a choice of declaring a variable using an anonymous type or an interface type:</p>
<p><strong>Anonymously-typed var</strong></p>
<pre><code class="lang-js">declare var MyPoint: { x: number; y: number; };
</code></pre>
<p><strong>Interfaced-typed var</strong></p>
<pre><code class="lang-js">interface SomePoint { x: number; y: number; }
declare var MyPoint: SomePoint;
</code></pre>
<p>From a consumption side these declarations are identical, but the type SomePoint can be extended through interface merging:</p>
<pre><code class="lang-js">interface SomePoint { z: number; }
MyPoint.z = 4; // OK
</code></pre>
<p>Whether or not you want your declarations to be extensible in this way is a bit of a judgement call. As always, try to represent the intent of the library here.</p>
<h3 class="section-title"><a name="Class Decomposition" class="anchor" href="#Class Decomposition"><span class="header-link"></span></a>Class Decomposition</h3><p>Classes in TypeScript create two separate types: the instance type, which defines what members an instance of a class has, and the constructor function type, which defines what members the class constructor function has. The constructor function type is also known as the &quot;static side&quot; type because it includes static members of the class.</p>
<p>While you can reference the static side of a class using the typeof keyword, it is sometimes useful or necessary when writing definition files to use the decomposed class pattern which explicitly separates the instance and static types of class.</p>
<p>As an example, the following two declarations are nearly equivalent from a consumption perspective:</p>
<p><strong>Standard</strong></p>
<pre><code class="lang-js">class A {
    static st: string;
    inst: number;
    constructor(m: any) {}
}
</code></pre>
<p><strong>Decomposed</strong></p>
<pre><code class="lang-js">interface A_Static {
    new(m: any): A_Instance;
    st: string;
}
interface A_Instance {
    inst: number;
}
declare var A: A_Static;
</code></pre>
<p>The trade-offs here are as follows:
Standard classes can be inherited from using extends; decomposed classes cannot. This might change in later version of TypeScript if arbitrary extends expressions are allowed.
It is possible to add members later (through declaration merging) to the static side of both standard and decomposed classes
It is possible to add instance members to decomposed classes, but not standard classes
You&#39;ll need to come up with sensible names for more types when writing a decomposed class</p>
<h3 class="section-title"><a name="Naming Conventions" class="anchor" href="#Naming Conventions"><span class="header-link"></span></a>Naming Conventions</h3><p>In general, do not prefix interfaces with I (e.g. IColor). Because the concept of an interface in TypeScript is much more broad than in C# or Java, the IFoo naming convention is not broadly useful.</p>
<h2 class="section-title"><a name="Examples" class="anchor" href="#Examples"><span class="header-link"></span></a>Examples</h2><p>Let&#39;s jump in to the examples section. For each example, sample usage of the library is provided, followed by the definition code that accurately types the usage. When there are multiple good representations, more than one definition sample might be listed.</p>
<h3 class="section-title"><a name="Options Objects" class="anchor" href="#Options Objects"><span class="header-link"></span></a>Options Objects</h3><p><strong>Usage</strong></p>
<pre><code class="lang-js">animalFactory.create(&quot;dog&quot;);
animalFactory.create(&quot;giraffe&quot;, { name: &quot;ronald&quot; });
animalFactory.create(&quot;panda&quot;, { name: &quot;bob&quot;, height: 400 });
// Invalid: name must be provided if options is given
animalFactory.create(&quot;cat&quot;, { height: 32 });
</code></pre>
<p><strong>Typing</strong></p>
<pre><code class="lang-js">module animalFactory {
    interface AnimalOptions {
        name: string;
        height?: number;
        weight?: number;
    }
    function create(name: string, animalOptions?: AnimalOptions): Animal;
}
</code></pre>
<h3 class="section-title"><a name="Functions with Properties" class="anchor" href="#Functions with Properties"><span class="header-link"></span></a>Functions with Properties</h3><p><strong>Usage</strong></p>
<pre><code class="lang-js">zooKeeper.workSchedule = &quot;morning&quot;;
zooKeeper(giraffeCage);
</code></pre>
<p><strong>Typing</strong></p>
<pre><code class="lang-js">// Note: Function must precede module
function zooKeeper(cage: AnimalCage);
module zooKeeper {
    var workSchedule: string;
}
</code></pre>
<h3 class="section-title"><a name="New + callable methods" class="anchor" href="#New + callable methods"><span class="header-link"></span></a>New + callable methods</h3><p><strong>Usage</strong></p>
<pre><code class="lang-js">var w = widget(32, 16);
var y = new widget(&quot;sprocket&quot;);
// w and y are both widgets
w.sprock();
y.sprock();
</code></pre>
<p><strong>Typing</strong></p>
<pre><code class="lang-js">interface Widget {
    sprock(): void;
}

interface WidgetFactory {
    new(name: string): Widget;
    (width: number, height: number): Widget;
}

declare var widget: WidgetFactory;
</code></pre>
<h3 class="section-title"><a name="Global / External-agnostic Libraries" class="anchor" href="#Global / External-agnostic Libraries"><span class="header-link"></span></a>Global / External-agnostic Libraries</h3><p><strong>Usage</strong></p>
<pre><code class="lang-js">// Either
import x = require(&#39;zoo&#39;);
x.open();
// or
zoo.open();
</code></pre>
<p><strong>Typing</strong></p>
<pre><code class="lang-js">module zoo {
  function open(): void;
}

declare module &quot;zoo&quot; {
    export = zoo;
}
</code></pre>
<h3 class="section-title"><a name="Single Complex Object in External Modules" class="anchor" href="#Single Complex Object in External Modules"><span class="header-link"></span></a>Single Complex Object in External Modules</h3><p><strong>Usage</strong></p>
<pre><code class="lang-js">// Super-chainable library for eagles
import eagle = require(&#39;./eagle&#39;);
// Call directly
eagle(&#39;bald&#39;).fly();
// Invoke with new
var eddie = new eagle(1000);
// Set properties
eagle.favorite = &#39;golden&#39;;
</code></pre>
<p><strong>Typing</strong></p>
<pre><code class="lang-js">// Note: can use any name here, but has to be the same throughout this file
declare function eagle(name: string): eagle;
declare module eagle {
    var favorite: string;
    function fly(): void;
}
interface eagle {
    new(awesomeness: number): eagle;
}

export = eagle;
</code></pre>
<h3 class="section-title"><a name="Callbacks" class="anchor" href="#Callbacks"><span class="header-link"></span></a>Callbacks</h3><p><strong>Usage</strong></p>
<pre><code class="lang-js">addLater(3, 4, (x) =&gt; console.log(&#39;x = &#39; + x));
</code></pre>
<p><strong>Typing</strong></p>
<pre><code class="lang-js">// Note: &#39;void&#39; return type is preferred here
function addLater(x: number, y: number, (sum: number) =&gt; void): void;
</code></pre>
